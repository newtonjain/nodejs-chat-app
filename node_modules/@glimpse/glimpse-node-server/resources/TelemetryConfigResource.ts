'use strict';

import { IResource } from './IResource';
import { IServer } from '../IServer';
import crypto = require('crypto');
import fs = require('fs');
import os = require('os');
import path = require('path');

/* tslint:disable:no-var-requires */
const getmac = require('getmac');
/* tslint:enable:no-var-requires */

/**
 *  Shape of telemetry config resource returned from the server.
 */
export interface ITelemetryConfig {
    /** flag indicating if sending telemetry from client is enabled or disabled. */
    enabled: boolean;

    /** Application Insights endpoint URI for sending telemetry */
    uri: string;

    /** Application Insights instrumentation key */
    instrumentationKey: string;

    /** IP address of the glimpse client as observed by the glimpse server */
    clientIP: string;

    /** serverGlimpseVersion */
    glimpseServerVersion: string;

    /** unique ID for the machine hosting the server.  This is a SHA256 hash of the machine's mac address. */
    serverMachineId: string;

    /** name of the application hosting the glimpse.server */
    serverAppName: string;

    /** OS Platform where server is running */
    serverOSPlatform: string;

    /** OS Release where server is running */
    serverOSRelease: string;

    /** OS Type where server is running */
    serverOSType: string;

    /** link to Microsoft privacy Policy. */
    privacyPolicy: string;
}

/**
 * Resource for telemetry configuration details to enable client to send telemetry data.
 *
 * Microsoft values privacy.  For details, please see our privacy
 * statement at http://go.microsoft.com/fwlink/?LinkId=521839&CLCID=0409.
 */
export class Resource implements IResource {

    private serverAppName: string;
    private serverMachineId: string;
    private serverOSPlatform: string;
    private serverOSRelease: string;
    private serverOSType: string;
    private glimpseServerVersion: string;
    public name = 'telemetry-config';
    public templateName = 'telemetryConfigTemplate';
    public uriTemplate = '';
    public type = 'client';

    public constructor(server?: IServer) {
        this.serverAppName = Resource.computeAppName();
        this.glimpseServerVersion = Resource.computeGlimpseServerVersion();
        this.setMachineIdentity();
        this.serverOSPlatform = os.platform();
        this.serverOSRelease = os.release();
        this.serverOSType = os.type();
    }

    /**
     * Given a starting directory, attempts to find a file name of the specified name,
     * walking up the hierarchy.
     */
    private static findFileInParent(startDirectory, fileName) {
        let testPath = undefined;
        let stat = undefined;
        do {
            testPath = path.join(startDirectory, fileName);
            try {
                stat = fs.statSync(testPath);
            }
            catch (err) {
                // swallow error if file doesn't exist
            }
            startDirectory = path.dirname(startDirectory);
        } while ((!stat || !stat.isFile()) && startDirectory !== path.dirname(startDirectory));

        if (stat && stat.isFile()) {
            return testPath;
        }
        return undefined;
    }

    /**
     * Attempts to find the package.json file associated with the file
     * used as the "main" file for this running instance of node. 
     */
    private static findAppPackageDotJson() {
        const fileName = 'package.json';
        let dirName = path.dirname(require.main.filename);
        return Resource.findFileInParent(dirName, fileName);
    }

    /**
     * Attempt to determine the application's name from the "name" property in the 
     * package.json's associated with the "launch" file passed to node.
     */
    private static computeAppName() {
        let appName = '';
        const packageDotJson = Resource.findAppPackageDotJson();
        if (packageDotJson) {
            const json = require.main.require(packageDotJson);
            if (json && json.name) {
                appName = json.name;
            }
        }
        return appName;
    }

    /**
     * Find the glimpse.server package.json file  
     */
    private static findGlimpsePackageDotJson() {
        const fileName = 'package.json';
        let dirName = path.dirname(__dirname);
        return Resource.findFileInParent(dirName, fileName);
    }

    /**
     * Determine glimpse.server version from glimpse.server's package.json  
     */
    private static computeGlimpseServerVersion() {
        let glimpseVersion = '';
        const packageDotJson = Resource.findGlimpsePackageDotJson();
        if (packageDotJson) {
            const json = require.main.require(packageDotJson);
            if (json && json.version) {
                glimpseVersion = json.version;
            }
        }
        return glimpseVersion;
    }

    /**
     * Asynchronously computes a one-way hash of the current computer's mac address.
     * Returns a promise that resovles to this value.  
     * 
     * This is public only for test purposes.
     */
    public static computeMachineIdentity() {
        /* tslint:disable:no-any */
        let p: any = new (<any>global.Promise)((resolve, reject) => {
            /* tslint:enable:no-any */
            getmac.getMac(function (err, macAddress) {
                if (err) {
                    reject(err);
                }
                else {
                    const generatedHash = crypto.createHash('sha256')
                        .update(macAddress, 'utf-8')
                        .digest('hex');
                    resolve(generatedHash);
                }
            });
        });
        return p;
    }

    /**
     * Asynchronously set the machine identity value for this TelemetryConfigResource instance.
     * 
     * Public only for test purposes.
     */
    public setMachineIdentity() {
        return Resource.computeMachineIdentity().then(
            (machineId) => {
                this.serverMachineId = machineId;
            },
            (err) => {
                this.serverMachineId = 'Error Retrieving ID';
            });
    }

    /**
     *  returns an ITelemetryConfig object with the appropriate values. 
     */
    public createTelemetryConfig(clientIP: string): ITelemetryConfig {
        return {
            enabled: true,
            uri: 'https://vortex.data.microsoft.com/collect/v1',
            instrumentationKey: 'AIF-a96980ad-8a38-47a2-bbb0-328338b6964a',
            glimpseServerVersion: this.glimpseServerVersion,
            clientIP,
            serverMachineId: this.serverMachineId,
            serverAppName: this.serverAppName,
            serverOSPlatform: this.serverOSPlatform,
            serverOSRelease: this.serverOSRelease,
            serverOSType: this.serverOSType,
            privacyPolicy: 'http://go.microsoft.com/fwlink/?LinkId=521839&CLCID=0409'
        };
    }

    /**
     * Invoke the resource
     */
    public invoke(req, res) {
        if (!this.serverMachineId) {
            this.setMachineIdentity().then(
                this.sendResponse(req, res));
        }
        else {
            this.sendResponse(req, res);
        }
    }

    /**
     * helper method to send the repsonse
     */
    private sendResponse(req, res) {
        res.status(200);
        res.type('application/json');
        res.send(this.createTelemetryConfig(req.socket.remoteAddress));
    }
}
