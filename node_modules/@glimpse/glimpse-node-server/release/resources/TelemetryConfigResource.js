'use strict';
var crypto = require('crypto');
var fs = require('fs');
var os = require('os');
var path = require('path');
/* tslint:disable:no-var-requires */
var getmac = require('getmac');
/**
 * Resource for telemetry configuration details to enable client to send telemetry data.
 *
 * Microsoft values privacy.  For details, please see our privacy
 * statement at http://go.microsoft.com/fwlink/?LinkId=521839&CLCID=0409.
 */
var Resource = (function () {
    function Resource(server) {
        this.name = 'telemetry-config';
        this.templateName = 'telemetryConfigTemplate';
        this.uriTemplate = '';
        this.type = 'client';
        this.serverAppName = Resource.computeAppName();
        this.glimpseServerVersion = Resource.computeGlimpseServerVersion();
        this.setMachineIdentity();
        this.serverOSPlatform = os.platform();
        this.serverOSRelease = os.release();
        this.serverOSType = os.type();
    }
    /**
     * Given a starting directory, attempts to find a file name of the specified name,
     * walking up the hierarchy.
     */
    Resource.findFileInParent = function (startDirectory, fileName) {
        var testPath = undefined;
        var stat = undefined;
        do {
            testPath = path.join(startDirectory, fileName);
            try {
                stat = fs.statSync(testPath);
            }
            catch (err) {
            }
            startDirectory = path.dirname(startDirectory);
        } while ((!stat || !stat.isFile()) && startDirectory !== path.dirname(startDirectory));
        if (stat && stat.isFile()) {
            return testPath;
        }
        return undefined;
    };
    /**
     * Attempts to find the package.json file associated with the file
     * used as the "main" file for this running instance of node.
     */
    Resource.findAppPackageDotJson = function () {
        var fileName = 'package.json';
        var dirName = path.dirname(require.main.filename);
        return Resource.findFileInParent(dirName, fileName);
    };
    /**
     * Attempt to determine the application's name from the "name" property in the
     * package.json's associated with the "launch" file passed to node.
     */
    Resource.computeAppName = function () {
        var appName = '';
        var packageDotJson = Resource.findAppPackageDotJson();
        if (packageDotJson) {
            var json = require.main.require(packageDotJson);
            if (json && json.name) {
                appName = json.name;
            }
        }
        return appName;
    };
    /**
     * Find the glimpse.server package.json file
     */
    Resource.findGlimpsePackageDotJson = function () {
        var fileName = 'package.json';
        var dirName = path.dirname(__dirname);
        return Resource.findFileInParent(dirName, fileName);
    };
    /**
     * Determine glimpse.server version from glimpse.server's package.json
     */
    Resource.computeGlimpseServerVersion = function () {
        var glimpseVersion = '';
        var packageDotJson = Resource.findGlimpsePackageDotJson();
        if (packageDotJson) {
            var json = require.main.require(packageDotJson);
            if (json && json.version) {
                glimpseVersion = json.version;
            }
        }
        return glimpseVersion;
    };
    /**
     * Asynchronously computes a one-way hash of the current computer's mac address.
     * Returns a promise that resovles to this value.
     *
     * This is public only for test purposes.
     */
    Resource.computeMachineIdentity = function () {
        /* tslint:disable:no-any */
        var p = new global.Promise(function (resolve, reject) {
            /* tslint:enable:no-any */
            getmac.getMac(function (err, macAddress) {
                if (err) {
                    reject(err);
                }
                else {
                    var generatedHash = crypto.createHash('sha256')
                        .update(macAddress, 'utf-8')
                        .digest('hex');
                    resolve(generatedHash);
                }
            });
        });
        return p;
    };
    /**
     * Asynchronously set the machine identity value for this TelemetryConfigResource instance.
     *
     * Public only for test purposes.
     */
    Resource.prototype.setMachineIdentity = function () {
        var _this = this;
        return Resource.computeMachineIdentity().then(function (machineId) {
            _this.serverMachineId = machineId;
        }, function (err) {
            _this.serverMachineId = 'Error Retrieving ID';
        });
    };
    /**
     *  returns an ITelemetryConfig object with the appropriate values.
     */
    Resource.prototype.createTelemetryConfig = function (clientIP) {
        return {
            enabled: true,
            uri: 'https://vortex.data.microsoft.com/collect/v1',
            instrumentationKey: 'AIF-a96980ad-8a38-47a2-bbb0-328338b6964a',
            glimpseServerVersion: this.glimpseServerVersion,
            clientIP: clientIP,
            serverMachineId: this.serverMachineId,
            serverAppName: this.serverAppName,
            serverOSPlatform: this.serverOSPlatform,
            serverOSRelease: this.serverOSRelease,
            serverOSType: this.serverOSType,
            privacyPolicy: 'http://go.microsoft.com/fwlink/?LinkId=521839&CLCID=0409'
        };
    };
    /**
     * Invoke the resource
     */
    Resource.prototype.invoke = function (req, res) {
        if (!this.serverMachineId) {
            this.setMachineIdentity().then(this.sendResponse(req, res));
        }
        else {
            this.sendResponse(req, res);
        }
    };
    /**
     * helper method to send the repsonse
     */
    Resource.prototype.sendResponse = function (req, res) {
        res.status(200);
        res.type('application/json');
        res.send(this.createTelemetryConfig(req.socket.remoteAddress));
    };
    return Resource;
}());
exports.Resource = Resource;

//# sourceMappingURL=../../maps/resources/TelemetryConfigResource.js.map
