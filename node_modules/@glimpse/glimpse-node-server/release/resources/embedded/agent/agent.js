/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var sprintf_js_1 = __webpack_require__(1);
	var Messaging_ts_1 = __webpack_require__(2);
	var Common_ts_1 = __webpack_require__(4);
	var XHRProxy_ts_1 = __webpack_require__(5);
	var ResourceTimingProxy_ts_1 = __webpack_require__(7);
	var XHRInspector_ts_1 = __webpack_require__(8);
	var ResourceTimingInspector_ts_1 = __webpack_require__(13);
	new XHRProxy_ts_1.XHRProxy().init();
	new ResourceTimingProxy_ts_1.ResourceTimingProxy().init();
	new XHRInspector_ts_1.XHRInspector().init(Messaging_ts_1.publishMessage);
	new ResourceTimingInspector_ts_1.ResourceTimingInspector().init(Messaging_ts_1.publishMessage);
	/* tslint:disable */
	// TODO: convert the rest of this to separate files:
	// https://github.com/Glimpse/Glimpse.Browser.Agent/issues/12
	(function () {
	    var processor = (function () {
	        var _strategies = [];
	        return {
	            register: function (strategy) {
	                _strategies.push(strategy);
	            },
	            execute: function () {
	                for (var i = 0; i < _strategies.length; i++) {
	                    _strategies[i]();
	                }
	            }
	        };
	    })();
	    // proxy console logging
	    (function wrapConsoleMethods() {
	        // Returns an array of ReplacementRegion objects, where start is inclusive and end is exclusive.
	        function getReplacementRegions(formatArgs) {
	            var format = formatArgs[0];
	            var regions = [];
	            if (typeof format !== 'string') {
	                return regions;
	            }
	            var params = Array.prototype.slice.call(formatArgs, 1);
	            if (params && params.length > 0) {
	                var currentParam = 0;
	                var nextStart = 0;
	                var i = 0;
	                while (i < format.length && currentParam < params.length) {
	                    if (format[i] === '%' && i < format.length - 1) {
	                        var nextChar = format[i + 1];
	                        if (nextChar === '%') {
	                            // escaped percent, advance i by 2 and nextStart by 1
	                            i += 2;
	                            nextStart += 1;
	                        }
	                        else if (nextChar === 's' || nextChar === 'd' || nextChar === 'j') {
	                            var region = {
	                                start: 0,
	                                end: 0
	                            };
	                            var currentFormat = '%' + nextChar;
	                            /* eslint-disable no-undef */
	                            var currentFormattedLength = sprintf_js_1.sprintf(currentFormat, params[currentParam]).length;
	                            /* eslint-enable no-undef */
	                            region.start = nextStart;
	                            nextStart += currentFormattedLength;
	                            region.end = nextStart;
	                            regions.push(region);
	                            currentParam++;
	                            i += 2;
	                        }
	                        else {
	                            // unescaped %, just advance
	                            i++;
	                            nextStart++;
	                        }
	                    }
	                    else {
	                        i++;
	                        nextStart++;
	                    }
	                }
	            }
	            return regions;
	        }
	        function getFormatInfo(args, index) {
	            var formatArgs = Array.prototype.slice.call(args, index);
	            var message = undefined;
	            var formatInfo = undefined;
	            try {
	                /* eslint-disable no-undef */
	                message = sprintf_js_1.sprintf.apply(null, formatArgs);
	                /* eslint-enable no-undef */
	                formatInfo = {
	                    message: message,
	                    replacementRegions: getReplacementRegions(formatArgs)
	                };
	            }
	            catch (e) {
	                formatInfo = {
	                    message: 'Exception - ' + e.message,
	                    replacementRegions: []
	                };
	            }
	            return formatInfo;
	        }
	        function getData(method, args) {
	            var logLevel = {
	                Debug: 'Debug',
	                Verbose: 'Verbose',
	                Information: 'Information',
	                Warning: 'Warning',
	                Error: 'Error',
	                Critical: 'Critical'
	            };
	            var data = undefined;
	            var formatInfo = undefined;
	            switch (method) {
	                case 'assert':
	                    formatInfo = getFormatInfo(args, 1);
	                    data = {
	                        message: formatInfo.message,
	                        level: logLevel.Error,
	                        replacedRegions: formatInfo.replacementRegions
	                    };
	                    break;
	                case 'debug':
	                case 'error':
	                    formatInfo = getFormatInfo(args, 0);
	                    data = {
	                        message: formatInfo.message,
	                        level: logLevel.Error,
	                        replacedRegions: undefined
	                    };
	                    break;
	                case 'info':
	                    formatInfo = getFormatInfo(args, 0);
	                    data = {
	                        message: formatInfo.message,
	                        level: logLevel.Information,
	                        replacedRegions: undefined
	                    };
	                    break;
	                case 'time':
	                case 'timeEnd':
	                case 'log':
	                    formatInfo = getFormatInfo(args, 0);
	                    data = {
	                        message: formatInfo.message,
	                        level: logLevel.Verbose,
	                        replacedRegions: formatInfo.replacementRegions
	                    };
	                    break;
	                case 'warn':
	                    formatInfo = getFormatInfo(args, 0);
	                    data = {
	                        message: formatInfo.message,
	                        level: logLevel.Warning,
	                        replacedRegions: formatInfo.replacementRegions
	                    };
	                    break;
	                case 'trace':
	                case 'timeStamp':
	                    data = {
	                        message: '',
	                        level: 0,
	                        replacedRegions: undefined
	                    };
	                    break;
	            }
	            return data;
	        }
	        var methods = [
	            'log',
	            'warn',
	            'error',
	            'info',
	            'time',
	            'timeEnd',
	            'assert',
	            'trace',
	            'timeStamp',
	            'debug'
	        ];
	        /* eslint-disable no-console */
	        methods.forEach(function (method) {
	            var oldMethod = console[method];
	            console[method] = function () {
	                var data = getData(method, arguments);
	                var regions = data.replacedRegions;
	                data.replacedRegions = (regions && regions.length > 0) ? regions : undefined;
	                data.startTime = Common_ts_1.getDateTime();
	                data.category = undefined;
	                data.source = 'Client';
	                Messaging_ts_1.publishMessage('log-write', data);
	                oldMethod.apply(this, arguments);
	            };
	        });
	        /* eslint-enable no-console */
	    })();
	    (function () {
	        function getTiming() {
	            var performance = window.performance ||
	                window.webkitPerformance ||
	                window.msPerformance ||
	                window.mozPerformance;
	            if (performance == null) {
	                return;
	            }
	            return performance.timing;
	        }
	        function processTimings(timing) {
	            var api = {
	                firstPaint: undefined,
	                firstPaintTime: undefined,
	                loadTime: undefined,
	                domReadyTime: undefined,
	                readyStart: undefined,
	                redirectTime: undefined,
	                appcacheTime: undefined,
	                unloadEventTime: undefined,
	                lookupDomainTime: undefined,
	                connectTime: undefined,
	                requestTime: undefined,
	                initDomTreeTime: undefined,
	                loadEventTime: undefined,
	                networkRequestTime: undefined,
	                networkResponseTime: undefined,
	                networkTime: undefined,
	                serverTime: undefined,
	                browserTime: undefined,
	                total: undefined
	            };
	            if (timing) {
	                // bring across intersting data
	                for (var k in timing) {
	                    if (typeof timing[k] !== 'function') {
	                        api[k] = timing[k];
	                    }
	                }
	                // time to first paint
	                if (api.firstPaint === undefined) {
	                    // All times are relative times to the start time within the
	                    // same objects
	                    var firstPaint = 0;
	                    // Chrome
	                    if (window.chrome && window.chrome.loadTimes) {
	                        // Convert to ms
	                        firstPaint = window.chrome.loadTimes().firstPaintTime * 1000;
	                        api.firstPaintTime = firstPaint - (window.chrome.loadTimes().startLoadTime * 1000);
	                    }
	                    else if (typeof window.performance.timing.msFirstPaint === 'number') {
	                        firstPaint = window.performance.timing.msFirstPaint;
	                        api.firstPaintTime = firstPaint - window.performance.timing.navigationStart;
	                    }
	                    api.firstPaint = firstPaint;
	                }
	                // total time from start to load
	                api.loadTime = timing.loadEventEnd - timing.fetchStart;
	                // time spent constructing the DOM tree
	                api.domReadyTime = timing.domComplete - timing.domInteractive;
	                // time consumed preparing the new page
	                api.readyStart = timing.fetchStart - timing.navigationStart;
	                // time spent during redirection
	                api.redirectTime = timing.redirectEnd - timing.redirectStart;
	                // appCache
	                api.appcacheTime = timing.domainLookupStart - timing.fetchStart;
	                // yime spent unloading documents
	                api.unloadEventTime = timing.unloadEventEnd - timing.unloadEventStart;
	                // DNS query time
	                api.lookupDomainTime = timing.domainLookupEnd - timing.domainLookupStart;
	                // TCP connection time
	                api.connectTime = timing.connectEnd - timing.connectStart;
	                // time spent during the request
	                api.requestTime = timing.responseEnd - timing.requestStart;
	                // request to completion of the DOM loading
	                api.initDomTreeTime = timing.domInteractive - timing.responseEnd;
	                // load event time
	                api.loadEventTime = timing.loadEventEnd - timing.loadEventStart;
	                // time spent on the network making the outgoing request
	                api.networkRequestTime = timing.requestStart - timing.navigationStart;
	                // time spent on the network receiving the incoming response
	                api.networkResponseTime = timing.responseEnd - timing.responseStart;
	                // time spent on the network for the whole request/response
	                api.networkTime = api.networkRequestTime + api.networkResponseTime;
	                // time spent on the server processing the request
	                api.serverTime = timing.responseEnd - timing.requestStart;
	                // time spent on the browser handling the response
	                api.browserTime = timing.loadEventEnd - timing.responseStart;
	                // total time
	                api.total = timing.loadEventEnd - timing.navigationStart;
	            }
	            return api;
	        }
	        // setup/regiter strategy to run later
	        Common_ts_1.addEvent(window, 'load', function () {
	            setTimeout(function () {
	                Messaging_ts_1.publishMessage('browser-navigation-timing', processTimings(getTiming()));
	            }, 0);
	        });
	    })();
	    processor.execute();
	})();
	/* tslint:enable */


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	(function(window) {
	    var re = {
	        not_string: /[^s]/,
	        number: /[diefg]/,
	        json: /[j]/,
	        not_json: /[^j]/,
	        text: /^[^\x25]+/,
	        modulo: /^\x25{2}/,
	        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
	        key: /^([a-z_][a-z_\d]*)/i,
	        key_access: /^\.([a-z_][a-z_\d]*)/i,
	        index_access: /^\[(\d+)\]/,
	        sign: /^[\+\-]/
	    }

	    function sprintf() {
	        var key = arguments[0], cache = sprintf.cache
	        if (!(cache[key] && cache.hasOwnProperty(key))) {
	            cache[key] = sprintf.parse(key)
	        }
	        return sprintf.format.call(null, cache[key], arguments)
	    }

	    sprintf.format = function(parse_tree, argv) {
	        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
	        for (i = 0; i < tree_length; i++) {
	            node_type = get_type(parse_tree[i])
	            if (node_type === "string") {
	                output[output.length] = parse_tree[i]
	            }
	            else if (node_type === "array") {
	                match = parse_tree[i] // convenience purposes only
	                if (match[2]) { // keyword argument
	                    arg = argv[cursor]
	                    for (k = 0; k < match[2].length; k++) {
	                        if (!arg.hasOwnProperty(match[2][k])) {
	                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
	                        }
	                        arg = arg[match[2][k]]
	                    }
	                }
	                else if (match[1]) { // positional argument (explicit)
	                    arg = argv[match[1]]
	                }
	                else { // positional argument (implicit)
	                    arg = argv[cursor++]
	                }

	                if (get_type(arg) == "function") {
	                    arg = arg()
	                }

	                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
	                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
	                }

	                if (re.number.test(match[8])) {
	                    is_positive = arg >= 0
	                }

	                switch (match[8]) {
	                    case "b":
	                        arg = arg.toString(2)
	                    break
	                    case "c":
	                        arg = String.fromCharCode(arg)
	                    break
	                    case "d":
	                    case "i":
	                        arg = parseInt(arg, 10)
	                    break
	                    case "j":
	                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
	                    break
	                    case "e":
	                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
	                    break
	                    case "f":
	                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
	                    break
	                    case "g":
	                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
	                    break
	                    case "o":
	                        arg = arg.toString(8)
	                    break
	                    case "s":
	                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case "u":
	                        arg = arg >>> 0
	                    break
	                    case "x":
	                        arg = arg.toString(16)
	                    break
	                    case "X":
	                        arg = arg.toString(16).toUpperCase()
	                    break
	                }
	                if (re.json.test(match[8])) {
	                    output[output.length] = arg
	                }
	                else {
	                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
	                        sign = is_positive ? "+" : "-"
	                        arg = arg.toString().replace(re.sign, "")
	                    }
	                    else {
	                        sign = ""
	                    }
	                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
	                    pad_length = match[6] - (sign + arg).length
	                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
	                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
	                }
	            }
	        }
	        return output.join("")
	    }

	    sprintf.cache = {}

	    sprintf.parse = function(fmt) {
	        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
	        while (_fmt) {
	            if ((match = re.text.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = match[0]
	            }
	            else if ((match = re.modulo.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = "%"
	            }
	            else if ((match = re.placeholder.exec(_fmt)) !== null) {
	                if (match[2]) {
	                    arg_names |= 1
	                    var field_list = [], replacement_field = match[2], field_match = []
	                    if ((field_match = re.key.exec(replacement_field)) !== null) {
	                        field_list[field_list.length] = field_match[1]
	                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
	                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else {
	                                throw new SyntaxError("[sprintf] failed to parse named argument key")
	                            }
	                        }
	                    }
	                    else {
	                        throw new SyntaxError("[sprintf] failed to parse named argument key")
	                    }
	                    match[2] = field_list
	                }
	                else {
	                    arg_names |= 2
	                }
	                if (arg_names === 3) {
	                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
	                }
	                parse_tree[parse_tree.length] = match
	            }
	            else {
	                throw new SyntaxError("[sprintf] unexpected placeholder")
	            }
	            _fmt = _fmt.substring(match[0].length)
	        }
	        return parse_tree
	    }

	    var vsprintf = function(fmt, argv, _argv) {
	        _argv = (argv || []).slice(0)
	        _argv.splice(0, 0, fmt)
	        return sprintf.apply(null, _argv)
	    }

	    /**
	     * helpers
	     */
	    function get_type(variable) {
	        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
	    }

	    function str_repeat(input, multiplier) {
	        return Array(multiplier + 1).join(input)
	    }

	    /**
	     * export to either browser or node.js
	     */
	    if (true) {
	        exports.sprintf = sprintf
	        exports.vsprintf = vsprintf
	    }
	    else {
	        window.sprintf = sprintf
	        window.vsprintf = vsprintf

	        if (typeof define === "function" && define.amd) {
	            define(function() {
	                return {
	                    sprintf: sprintf,
	                    vsprintf: vsprintf
	                }
	            })
	        }
	    }
	})(typeof window === "undefined" ? this : window);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var nanoajax_1 = __webpack_require__(3);
	var Common_ts_1 = __webpack_require__(4);
	exports.publishMessage = function publishMessage(type, payload) {
	    var message = {
	        id: Common_ts_1.getGuid(),
	        types: [type],
	        payload: payload,
	        context: {
	            id: Common_ts_1.getRequestId(),
	            type: 'Request'
	        }
	    };
	    message.payload = JSON.stringify(message);
	    nanoajax_1.ajax({
	        url: Common_ts_1.getMessageIngressUrl(),
	        method: 'POST',
	        body: JSON.stringify([message])
	    }, function () {
	        // not doing anything atm
	    });
	};


/***/ },
/* 3 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {// Best place to find information on XHR features is:
	// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest

	var reqfields = [
	  'responseType', 'withCredentials', 'timeout', 'onprogress'
	]

	// Simple and small ajax function
	// Takes a parameters object and a callback function
	// Parameters:
	//  - url: string, required
	//  - headers: object of `{header_name: header_value, ...}`
	//  - body:
	//      + string (sets content type to 'application/x-www-form-urlencoded' if not set in headers)
	//      + FormData (doesn't set content type so that browser will set as appropriate)
	//  - method: 'GET', 'POST', etc. Defaults to 'GET' or 'POST' based on body
	//  - cors: If your using cross-origin, you will need this true for IE8-9
	//
	// The following parameters are passed onto the xhr object.
	// IMPORTANT NOTE: The caller is responsible for compatibility checking.
	//  - responseType: string, various compatability, see xhr docs for enum options
	//  - withCredentials: boolean, IE10+, CORS only
	//  - timeout: long, ms timeout, IE8+
	//  - onprogress: callback, IE10+
	//
	// Callback function prototype:
	//  - statusCode from request
	//  - response
	//    + if responseType set and supported by browser, this is an object of some type (see docs)
	//    + otherwise if request completed, this is the string text of the response
	//    + if request is aborted, this is "Abort"
	//    + if request times out, this is "Timeout"
	//    + if request errors before completing (probably a CORS issue), this is "Error"
	//  - request object
	//
	// Returns the request object. So you can call .abort() or other methods
	//
	// DEPRECATIONS:
	//  - Passing a string instead of the params object has been removed!
	//
	exports.ajax = function (params, callback) {
	  // Any variable used more than once is var'd here because
	  // minification will munge the variables whereas it can't munge
	  // the object access.
	  var headers = params.headers || {}
	    , body = params.body
	    , method = params.method || (body ? 'POST' : 'GET')
	    , called = false

	  var req = getRequest(params.cors)

	  function cb(statusCode, responseText) {
	    return function () {
	      if (!called) {
	        callback(req.status === undefined ? statusCode : req.status,
	                 req.status === 0 ? "Error" : (req.response || req.responseText || responseText),
	                 req)
	        called = true
	      }
	    }
	  }

	  req.open(method, params.url, true)

	  var success = req.onload = cb(200)
	  req.onreadystatechange = function () {
	    if (req.readyState === 4) success()
	  }
	  req.onerror = cb(null, 'Error')
	  req.ontimeout = cb(null, 'Timeout')
	  req.onabort = cb(null, 'Abort')

	  if (body) {
	    setDefault(headers, 'X-Requested-With', 'XMLHttpRequest')

	    if (!global.FormData || !(body instanceof global.FormData)) {
	      setDefault(headers, 'Content-Type', 'application/x-www-form-urlencoded')
	    }
	  }

	  for (var i = 0, len = reqfields.length, field; i < len; i++) {
	    field = reqfields[i]
	    if (params[field] !== undefined)
	      req[field] = params[field]
	  }

	  for (var field in headers)
	    req.setRequestHeader(field, headers[field])

	  req.send(body)

	  return req
	}

	function getRequest(cors) {
	  // XDomainRequest is only way to do CORS in IE 8 and 9
	  // But XDomainRequest isn't standards-compatible
	  // Notably, it doesn't allow cookies to be sent or set by servers
	  // IE 10+ is standards-compatible in its XMLHttpRequest
	  // but IE 10 can still have an XDomainRequest object, so we don't want to use it
	  if (cors && global.XDomainRequest && !/MSIE 1/.test(navigator.userAgent))
	    return new XDomainRequest
	  if (global.XMLHttpRequest)
	    return new XMLHttpRequest
	}

	function setDefault(obj, key, value) {
	  obj[key] = obj[key] || value
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	function addEvent(element, eventName, cb) {
	    if (element.addEventListener) {
	        element.addEventListener(eventName, cb, false);
	    }
	    else if (element.attachEvent) {
	        element.attachEvent('on' + eventName, cb);
	    }
	}
	exports.addEvent = addEvent;
	function getCookie(cookie) {
	    // Modified from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
	    var regexp = new RegExp('(?:(?:^|.*;\\s*)' + cookie + '\\s*\\=\\s*([^;]*).*$)|^.*$');
	    return document.cookie.replace(regexp, '$1');
	}
	exports.getCookie = getCookie;
	function getRequestId() {
	    var id = document.getElementById('__glimpse_browser_agent').getAttribute('data-request-id');
	    if (!id) {
	        id = getCookie('.Glimpse.RequestId');
	    }
	    if (!id) {
	        id = getGuid();
	    }
	    return id;
	}
	exports.getRequestId = getRequestId;
	function getMessageIngressUrl() {
	    return document.getElementById('__glimpse_browser_agent').getAttribute('data-message-ingress-template');
	}
	exports.getMessageIngressUrl = getMessageIngressUrl;
	function getGuid() {
	    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	        /* tslint:disable:no-bitwise */
	        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
	        /* tslint:enable:no-bitwise */
	        return v.toString(16);
	    });
	}
	exports.getGuid = getGuid;
	function parseUrl(url) {
	    var parser = document.createElement('a');
	    parser.href = url;
	    return {
	        protocol: parser.protocol,
	        hostname: parser.hostname,
	        port: parseInt(parser.port, 10),
	        pathname: parser.pathname,
	        search: parser.search,
	        hash: parser.hash
	    };
	}
	exports.parseUrl = parseUrl;
	function stringifyUrl(url) {
	    var stringifiedUrl = url.protocol + "//" + url.hostname + ":" + url.port + url.pathname;
	    if (url.search) {
	        stringifiedUrl += "?" + url.search;
	    }
	    if (url.hash) {
	        stringifiedUrl += "#" + url.hash;
	    }
	    return stringifiedUrl;
	}
	exports.stringifyUrl = stringifyUrl;
	var urlCache = {};
	function resolveUrl(url) {
	    if (urlCache[url]) {
	        return urlCache[url];
	    }
	    return urlCache[url] = stringifyUrl(parseUrl(url));
	}
	exports.resolveUrl = resolveUrl;
	function toTwoDigits(value) {
	    return value < 10 ? '0' + value : value;
	}
	function toThreeDigits(value) {
	    if (value < 10) {
	        return '00' + value;
	    }
	    if (value < 100) {
	        return '0' + value;
	    }
	    return value;
	}
	function getUTCOffset(date) {
	    var offset = date.getTimezoneOffset();
	    var sign = (offset > 0) ? '-' : '+';
	    offset = Math.abs(offset);
	    var hours = toTwoDigits(Math.floor(offset / 60));
	    var minutes = toTwoDigits(offset % 60);
	    return sign + hours + minutes;
	}
	// Convert time according to the format string: 'YYYY-MM-DDTHH:mm:ss.SSS ZZ'
	// Output should look like: "2016-06-08T09:07:11.021 -0700"
	function getDateTime(d) {
	    if (d === void 0) { d = new Date(); }
	    return d.getFullYear() + '-' + toTwoDigits(d.getMonth() + 1) + '-' + toTwoDigits(d.getDate()) + 'T' +
	        toTwoDigits(d.getHours()) + ':' + toTwoDigits(d.getMinutes()) + ':' + toTwoDigits(d.getSeconds()) + '.' +
	        toThreeDigits(d.getMilliseconds()) + ' ' + getUTCOffset(d);
	}
	exports.getDateTime = getDateTime;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Tracing_ts_1 = __webpack_require__(6);
	var Common_ts_1 = __webpack_require__(4);
	exports.EVENT_REQUEST_SENT = 'invoke|pre|XMLHttpRequest.request-sent';
	exports.EVENT_RESPONSE_RECEIVED = 'notify|XMLHttpRequest.response-received';
	exports.EVENT_ERROR = 'notify|XMLHttpRequest.error';
	exports.EVENT_ABORT = 'notify|XMLHttpRequest.abort';
	var XHRProxy = (function () {
	    function XHRProxy() {
	    }
	    XHRProxy.prototype.init = function () {
	        if (XHRProxy.isInitialized) {
	            throw new Error('Cannot initialize the XHR Proxy more than once');
	        }
	        // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we
	        // reference the property this way to get around TypeScript, but we also have to
	        // disable tslint in the process
	        /* tslint:disable */
	        var oldXMLHttpRequest = window['XMLHttpRequest'];
	        /* tslint:enable */
	        function XMLHttpRequest() {
	            var constructorArgs = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                constructorArgs[_i - 0] = arguments[_i];
	            }
	            var xhr = new (oldXMLHttpRequest.bind.apply(oldXMLHttpRequest, [void 0].concat(constructorArgs)))();
	            var id = Common_ts_1.getGuid();
	            function handleAsyncRequest(method, url) {
	                var requestHeaders = {};
	                xhr.addEventListener('readystatechange', function () {
	                    if (xhr.readyState === oldXMLHttpRequest.DONE) {
	                        var eventData = {
	                            id: id,
	                            xhr: xhr,
	                            url: Common_ts_1.resolveUrl(url),
	                            statusCode: xhr.status,
	                            bodyType: xhr.responseType,
	                            body: xhr.response
	                        };
	                        Tracing_ts_1.default.publish(exports.EVENT_RESPONSE_RECEIVED, eventData);
	                    }
	                    ;
	                });
	                xhr.addEventListener('error', function () {
	                    var eventData = {
	                        id: id,
	                        xhr: xhr,
	                        error: xhr.statusText
	                    };
	                    Tracing_ts_1.default.publish(exports.EVENT_ERROR, eventData);
	                });
	                xhr.addEventListener('abort', function () {
	                    var eventData = {
	                        id: id,
	                        xhr: xhr
	                    };
	                    Tracing_ts_1.default.publish(exports.EVENT_ABORT, eventData);
	                });
	                var oldSend = xhr.send;
	                xhr.send = function send(body) {
	                    var sendArgs = [];
	                    for (var _i = 1; _i < arguments.length; _i++) {
	                        sendArgs[_i - 1] = arguments[_i];
	                    }
	                    var eventData = {
	                        id: id,
	                        xhr: xhr,
	                        method: method,
	                        url: Common_ts_1.resolveUrl(url),
	                        body: body,
	                        headers: requestHeaders
	                    };
	                    Tracing_ts_1.default.publish(exports.EVENT_REQUEST_SENT, eventData);
	                    oldSend.call.apply(oldSend, [this, body].concat(sendArgs));
	                };
	                var oldSetRequestHeader = xhr.setRequestHeader;
	                xhr.setRequestHeader = function setRequestHeader(header, value) {
	                    var setRequestHeaderArgs = [];
	                    for (var _i = 2; _i < arguments.length; _i++) {
	                        setRequestHeaderArgs[_i - 2] = arguments[_i];
	                    }
	                    requestHeaders[header] = value;
	                    oldSetRequestHeader.call.apply(oldSetRequestHeader, [this, header, value].concat(setRequestHeaderArgs));
	                };
	            }
	            function handleSyncRequest(method, url) {
	                var oldSend = xhr.send;
	                var requestHeaders = {};
	                var oldSetRequestHeader = xhr.setRequestHeader;
	                xhr.setRequestHeader = function setRequestHeader(header, value) {
	                    var setRequestHeaderArgs = [];
	                    for (var _i = 2; _i < arguments.length; _i++) {
	                        setRequestHeaderArgs[_i - 2] = arguments[_i];
	                    }
	                    requestHeaders[header] = value;
	                    oldSetRequestHeader.call.apply(oldSetRequestHeader, [this, header, value].concat(setRequestHeaderArgs));
	                };
	                xhr.send = function send(body) {
	                    var sendArgs = [];
	                    for (var _i = 1; _i < arguments.length; _i++) {
	                        sendArgs[_i - 1] = arguments[_i];
	                    }
	                    var requestEventData = {
	                        id: id,
	                        xhr: xhr,
	                        method: method,
	                        url: Common_ts_1.resolveUrl(url),
	                        body: body,
	                        headers: requestHeaders
	                    };
	                    Tracing_ts_1.default.publish(exports.EVENT_REQUEST_SENT, requestEventData);
	                    try {
	                        oldSend.call.apply(oldSend, [this, body].concat(sendArgs));
	                    }
	                    catch (e) {
	                        var errorEventData = {
	                            id: id,
	                            xhr: xhr,
	                            error: e.message
	                        };
	                        Tracing_ts_1.default.publish(exports.EVENT_ERROR, errorEventData);
	                        throw e;
	                    }
	                    var responseEventData = {
	                        id: id,
	                        xhr: xhr,
	                        url: Common_ts_1.resolveUrl(url),
	                        statusCode: xhr.status,
	                        bodyType: xhr.responseType,
	                        body: xhr.response
	                    };
	                    Tracing_ts_1.default.publish(exports.EVENT_RESPONSE_RECEIVED, responseEventData);
	                };
	            }
	            var oldOpen = xhr.open;
	            xhr.open = function open(method, url, async) {
	                if (async === void 0) { async = true; }
	                var openArgs = [];
	                for (var _i = 3; _i < arguments.length; _i++) {
	                    openArgs[_i - 3] = arguments[_i];
	                }
	                var result = oldOpen.call.apply(oldOpen, [this, method, url, async].concat(openArgs));
	                // If the url equals the message ingress url, that means it's
	                // a Glimpse message and we don't want to profile it
	                if (url !== Common_ts_1.getMessageIngressUrl()) {
	                    if (async) {
	                        handleAsyncRequest(method, url);
	                    }
	                    else {
	                        handleSyncRequest(method, url);
	                    }
	                }
	                return result;
	            };
	            return xhr;
	        }
	        // Copy the states (and anything else) from the original object to our proxy
	        for (var prop in oldXMLHttpRequest) {
	            if (oldXMLHttpRequest.hasOwnProperty(prop)) {
	                XMLHttpRequest[prop] = oldXMLHttpRequest[prop];
	            }
	        }
	        // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we
	        // reference the property this way to get around TypeScript, but we also have to
	        // disable tslint in the process
	        /* tslint:disable */
	        window['XMLHttpRequest'] = XMLHttpRequest;
	        /* tslint:enable */
	        XHRProxy.isInitialized = true;
	    };
	    XHRProxy.isInitialized = false;
	    return XHRProxy;
	}());
	exports.XHRProxy = XHRProxy;


/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	var Tracing = (function () {
	    function Tracing() {
	        this.listeners = {};
	    }
	    /**
	     * Publishes an event, similar to the `EventEmitter.emit` method except that it
	     * does not accept more than one data argument.
	     *
	     * @param {string} event - The name of the event to fire, and should include a
	     *      descriptive namespace, e.g. `http.request:request-created`
	     * @param {object} data - The data associated with the event
	     * @returns {boolean} - Whether or not the event was published to any listeners
	     */
	    Tracing.prototype.publish = function (event, data) {
	        var listeners = this.listeners[event];
	        if (!listeners || listeners.length === 0) {
	            return false;
	        }
	        var emitted = false;
	        var message = {
	            time: performance.now(),
	            timestamp: Date.now(),
	            data: data
	        };
	        for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {
	            var listener = listeners_1[_i];
	            emitted = true;
	            listener.listener(message);
	        }
	        return emitted;
	    };
	    /**
	     * Register to always receive an event without any filtering. This module is
	     * returned from this method, making it possible to chain `removeEventListener`
	     * calls.
	     *
	     * Note: if any other listeners are filtering this event, registering with
	     * this method will prevent the proxies from enabling any performance
	     * optimizations.
	     *
	     * Calling this method is equivalent to calling `onFiltered(event, listener, () => true)`
	     *
	     * @param {string} event - The name of the event to listen to, e.g.
	     *      `http.request:request-created`
	     * @param {function} listener - The callback to call when the event is emitted
	     */
	    Tracing.prototype.on = function (event, listener) {
	        if (!this.listeners[event]) {
	            this.listeners[event] = [];
	        }
	        this.listeners[event].push({
	            listener: listener
	        });
	        return this;
	    };
	    /**
	     * Removes exactly one registered event listener. If the same callback is
	     * registered more than once, only the first copy is removed. This behavior
	     * mimics that of EventEmitter.removeEventListener
	     *
	     * @param {string} event - The name of the event to remove the listener for,
	     *      e.g. `http.request:request-created`
	     * @param {function} listener - The listener to remove
	     * @returns {object} A refernce to this module, making it possible to chain
	     *      removeEventListener calls
	     */
	    Tracing.prototype.removeEventListener = function (event, listener) {
	        var listeners = this.listeners[event];
	        if (!listeners) {
	            // Matches Node.js removeEventListener return signature
	            return this;
	        }
	        for (var i = 0; i < listeners.length; i++) {
	            if (listeners[i].listener === listener) {
	                this.listeners[event].splice(i, 1);
	                break;
	            }
	        }
	        return this;
	    };
	    /**
	     * Removes all listeners for the given event. If no event is specified, then
	     * all event listeners for all events are removed.
	     *
	     * @param {string} event - (Optional) The event to remove listeners for
	     * @returns {object} A refernce to this module, making it possible to chain calls
	     */
	    Tracing.prototype.removeAllListeners = function (event) {
	        if (event) {
	            if (this.listeners[event]) {
	                this.listeners[event] = [];
	            }
	        }
	        else {
	            this.listeners = {};
	        }
	        return this;
	    };
	    /**
	     * Returns the number of listeners for the given event. This behavior
	     * mimics that of EventEmitter.listenerCount
	     *
	     * @param {string} event - The event to count listeners for
	     * @returns {number} The number of listeners for the given event
	     */
	    Tracing.prototype.listenerCount = function (event) {
	        if (!this.listeners[event]) {
	            return 0;
	        }
	        return this.listeners[event].length;
	    };
	    return Tracing;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new Tracing();


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Tracing_ts_1 = __webpack_require__(6);
	var Common_ts_1 = __webpack_require__(4);
	var UPDATE_INTERVAL = 1000;
	exports.EVENT_RESOURCE_TIMING_COLLECTED = 'notify|performance.resource-collected';
	var ResourceTimingProxy = (function () {
	    function ResourceTimingProxy() {
	    }
	    ResourceTimingProxy.prototype.init = function () {
	        /* tslint:disable:no-any */
	        var performance = window.performance ||
	            window.webkitPerformance ||
	            window.msPerformance ||
	            window.mozPerformance;
	        /* tslint:enable:no-any */
	        // Don't initialize if this browser doesn't support resource timing
	        if (!performance || !performance.getEntriesByType) {
	            return;
	        }
	        function processEntry(entry) {
	            // This sheds any extra properties that may be introduced to resource timing
	            // or are browser specific, and ensures the data matches our interface for it.
	            return {
	                name: entry.name,
	                startTime: entry.startTime,
	                duration: entry.duration,
	                initiatorType: entry.initiatorType,
	                nextHopProtocol: entry.nextHopProtocol,
	                redirectStart: entry.redirectStart,
	                redirectEnd: entry.redirectEnd,
	                fetchStart: entry.fetchStart,
	                domainLookupStart: entry.domainLookupStart,
	                domainLookupEnd: entry.domainLookupEnd,
	                connectStart: entry.connectStart,
	                connectEnd: entry.connectEnd,
	                secureConnectionStart: entry.secureConnectionStart,
	                requestStart: entry.requestStart,
	                responseStart: entry.responseStart,
	                responseEnd: entry.responseEnd,
	                transferSize: entry.transferSize,
	                encodedBodySize: entry.encodedBodySize,
	                decodedBodySize: entry.decodedBodySize
	            };
	        }
	        // Eventually we want to switch to using Performance Observers once browsers
	        // start to implement, but currently none do, so we poll for entries instead
	        // https://w3c.github.io/performance-timeline/#dom-performanceobserver
	        var reportedEntries = {};
	        function record() {
	            var resources = performance.getEntriesByType('resource');
	            var entriesToPublish = [];
	            var ingressUrl = Common_ts_1.getMessageIngressUrl();
	            for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {
	                var resource = resources_1[_i];
	                // Create a unique id for the entry, a combination of the start time
	                // and resolved URL
	                var id = resource.startTime + "#" + resource.name;
	                if (!reportedEntries[id] && resource.name.indexOf(ingressUrl) === -1) {
	                    reportedEntries[id] = true;
	                    entriesToPublish.push(processEntry(resource));
	                }
	            }
	            if (entriesToPublish.length) {
	                Tracing_ts_1.default.publish(exports.EVENT_RESOURCE_TIMING_COLLECTED, entriesToPublish);
	            }
	            setTimeout(record, UPDATE_INTERVAL);
	        }
	        ;
	        record();
	    };
	    return ResourceTimingProxy;
	}());
	exports.ResourceTimingProxy = ResourceTimingProxy;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var XHRProxy_ts_1 = __webpack_require__(5);
	var Tracing_ts_1 = __webpack_require__(6);
	var Common_ts_1 = __webpack_require__(4);
	var parse = __webpack_require__(9);
	var MAX_BODY_SIZE = 132000;
	var XHRInspector = (function () {
	    function XHRInspector() {
	        this.requests = {};
	    }
	    XHRInspector.prototype.before = function (data) {
	        var eventData = data.data;
	        var url = Common_ts_1.parseUrl(eventData.url);
	        // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307
	        // Add support for base64 encoding non-text content by setting the encoding here
	        var body = {
	            size: 0,
	            encoding: 'utf-8',
	            content: '',
	            isTruncated: false
	        };
	        if (eventData.body) {
	            body.size = eventData.body.length;
	            body.content = eventData.body.slice(0, MAX_BODY_SIZE);
	            body.isTruncated = body.size > MAX_BODY_SIZE;
	        }
	        this.publishMessage('browser-http-request', {
	            protocol: {
	                identifier: url.protocol.replace(/\:$/, '').toUpperCase()
	            },
	            url: eventData.url,
	            method: eventData.method,
	            startTime: Common_ts_1.getDateTime(new Date(data.timestamp)),
	            headers: eventData.headers,
	            isAjax: true,
	            body: body
	        });
	    };
	    XHRInspector.prototype.after = function (data, duration) {
	        var eventData = data.data;
	        // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307
	        // Add support for base64 encoding non-text content by setting the encoding here
	        var body = {
	            size: 0,
	            encoding: 'utf-8',
	            content: '',
	            isTruncated: false
	        };
	        if (eventData.body) {
	            body.size = eventData.body.length;
	            body.content = eventData.body.slice(0, MAX_BODY_SIZE);
	            body.isTruncated = body.size > MAX_BODY_SIZE;
	        }
	        this.publishMessage('browser-http-response', {
	            url: eventData.url,
	            headers: parse(eventData.xhr.getAllResponseHeaders()),
	            statusCode: eventData.statusCode,
	            endTime: Common_ts_1.getDateTime(new Date(data.timestamp)),
	            duration: duration,
	            body: body
	        });
	    };
	    XHRInspector.prototype.numOutstandingRequests = function () {
	        return Object.keys(this.requests).length;
	    };
	    XHRInspector.prototype.init = function (publishMessage) {
	        var _this = this;
	        this.publishMessage = publishMessage;
	        Tracing_ts_1.default.on(XHRProxy_ts_1.EVENT_REQUEST_SENT, function (data) {
	            _this.requests[data.data.id] = data.time;
	            _this.before(data);
	        });
	        Tracing_ts_1.default.on(XHRProxy_ts_1.EVENT_RESPONSE_RECEIVED, function (data) {
	            var startTime = _this.requests[data.data.id];
	            if (!startTime) {
	                throw new Error('Internal error: could not find associated master data');
	            }
	            _this.after(data, data.time - startTime);
	            delete _this.requests[data.data.id];
	        });
	        Tracing_ts_1.default.on(XHRProxy_ts_1.EVENT_ERROR, function (data) {
	            delete _this.requests[data.data.id];
	        });
	        Tracing_ts_1.default.on(XHRProxy_ts_1.EVENT_ABORT, function (data) {
	            delete _this.requests[data.data.id];
	        });
	    };
	    return XHRInspector;
	}());
	exports.XHRInspector = XHRInspector;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var trim = __webpack_require__(10)
	  , forEach = __webpack_require__(11)
	  , isArray = function(arg) {
	      return Object.prototype.toString.call(arg) === '[object Array]';
	    }

	module.exports = function (headers) {
	  if (!headers)
	    return {}

	  var result = {}

	  forEach(
	      trim(headers).split('\n')
	    , function (row) {
	        var index = row.indexOf(':')
	          , key = trim(row.slice(0, index)).toLowerCase()
	          , value = trim(row.slice(index + 1))

	        if (typeof(result[key]) === 'undefined') {
	          result[key] = value
	        } else if (isArray(result[key])) {
	          result[key].push(value)
	        } else {
	          result[key] = [ result[key], value ]
	        }
	      }
	  )

	  return result
	}

/***/ },
/* 10 */
/***/ function(module, exports) {

	
	exports = module.exports = trim;

	function trim(str){
	  return str.replace(/^\s*|\s*$/g, '');
	}

	exports.left = function(str){
	  return str.replace(/^\s*/, '');
	};

	exports.right = function(str){
	  return str.replace(/\s*$/, '');
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(12)

	module.exports = forEach

	var toString = Object.prototype.toString
	var hasOwnProperty = Object.prototype.hasOwnProperty

	function forEach(list, iterator, context) {
	    if (!isFunction(iterator)) {
	        throw new TypeError('iterator must be a function')
	    }

	    if (arguments.length < 3) {
	        context = this
	    }
	    
	    if (toString.call(list) === '[object Array]')
	        forEachArray(list, iterator, context)
	    else if (typeof list === 'string')
	        forEachString(list, iterator, context)
	    else
	        forEachObject(list, iterator, context)
	}

	function forEachArray(array, iterator, context) {
	    for (var i = 0, len = array.length; i < len; i++) {
	        if (hasOwnProperty.call(array, i)) {
	            iterator.call(context, array[i], i, array)
	        }
	    }
	}

	function forEachString(string, iterator, context) {
	    for (var i = 0, len = string.length; i < len; i++) {
	        // no such thing as a sparse string.
	        iterator.call(context, string.charAt(i), i, string)
	    }
	}

	function forEachObject(object, iterator, context) {
	    for (var k in object) {
	        if (hasOwnProperty.call(object, k)) {
	            iterator.call(context, object[k], k, object)
	        }
	    }
	}


/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = isFunction

	var toString = Object.prototype.toString

	function isFunction (fn) {
	  var string = toString.call(fn)
	  return string === '[object Function]' ||
	    (typeof fn === 'function' && string !== '[object RegExp]') ||
	    (typeof window !== 'undefined' &&
	     // IE8 and below
	     (fn === window.setTimeout ||
	      fn === window.alert ||
	      fn === window.confirm ||
	      fn === window.prompt))
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ResourceTimingProxy_ts_1 = __webpack_require__(7);
	var Tracing_ts_1 = __webpack_require__(6);
	var ResourceTimingInspector = (function () {
	    function ResourceTimingInspector() {
	    }
	    ResourceTimingInspector.prototype.init = function (publishMessage) {
	        Tracing_ts_1.default.on(ResourceTimingProxy_ts_1.EVENT_RESOURCE_TIMING_COLLECTED, function (data) {
	            // TODO: Eventually, we'll add more logic here to clean up data in
	            // https://github.com/Glimpse/Glimpse.Browser.Agent/issues/29.
	            publishMessage('browser-resource', data);
	        });
	    };
	    return ResourceTimingInspector;
	}());
	exports.ResourceTimingInspector = ResourceTimingInspector;


/***/ }
/******/ ]);