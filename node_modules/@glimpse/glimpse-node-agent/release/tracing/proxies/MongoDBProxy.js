'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Tracing_1 = require('../Tracing');
var ProxyBase_1 = require('./ProxyBase');
var moment = require('moment');
var fs = require('fs');
var path = require('path');
var semver = require('semver');
;
var MongoDBProxy = (function (_super) {
    __extends(MongoDBProxy, _super);
    function MongoDBProxy() {
        _super.apply(this, arguments);
        this.realCollectionMethods = {};
        this.realCursorMethods = {};
    }
    MongoDBProxy.prototype.getModuleNames = function () {
        return ['mongodb'];
    };
    ;
    Object.defineProperty(MongoDBProxy.prototype, "forceLoadModule", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    MongoDBProxy.prototype.init = function (mongodbModule, resolvedPath) {
        if (this.isVersionSupported(resolvedPath)) {
            var self_1 = this;
            /**
             * override of mongodb Collection.prototype.insert
             */
            function insertProxy() {
                var args = MongoDBProxy.swizzleArgs(arguments);
                if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT)) {
                    var data = {
                        originalArgs: args
                    };
                    Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT, data);
                }
                return self_1.realCollectionMethods.insert.apply(this, args);
            }
            // Collection overrides
            this.addProxyForCollectionMethod('insert', insertProxy, mongodbModule);
            this.setupCollectionProxy(['deleteMany', 'deleteOne', 'findOneAndDelete', 'remove'], this.deleteProxy, mongodbModule);
            this.setupCollectionProxy(['insertMany', 'insertOne'], this.insertMethodsProxy, mongodbModule);
            this.setupCollectionProxy(['updateOne', 'updateMany', 'replaceOne', 'findOneAndUpdate'], this.updateProxy, mongodbModule);
            this.setupCollectionProxy(['count'], this.collectionReadProxy, mongodbModule);
            // Cursor overrides
            this.setupCursorProxy(['toArray', 'next', 'nextObject'], this.cursorStartReadProxyCallbackOrPromise, mongodbModule);
            this.setupCursorProxy(['forEach', 'each'], this.cursorStartReadProxyCallbackNoPromise, mongodbModule);
        }
        return mongodbModule;
    };
    ;
    MongoDBProxy.prototype.isVersionSupported = function (resolvedPath) {
        if (resolvedPath.endsWith('MockMongoDB.js')) {
            // MockMongoDB is used for testing purposes, so always return true for that 
            return true;
        }
        var dir = path.dirname(resolvedPath);
        var pkgJSON = path.join(dir, 'package.json');
        if (fs.existsSync(pkgJSON)) {
            var contents = fs.readFileSync(pkgJSON, 'utf8');
            var parsed = JSON.parse(contents);
            if (parsed.version) {
                return semver.satisfies(parsed.version, '2.1.x');
            }
        }
        return false;
    };
    /**
     * Add a proxy for a mongoDB collection method
     */
    MongoDBProxy.prototype.setupCollectionProxy = function (targets, proxyHelper, mongoDBModule) {
        var _this = this;
        var self = this;
        for (var i = 0; i < targets.length; i++) {
            (function (key) {
                function proxy() {
                    return proxyHelper.call(self, key, this, arguments);
                }
                _this.addProxyForCollectionMethod(key, proxy, mongoDBModule);
            })(targets[i]);
        }
    };
    /**
     * Add a proxy for a mongoDB collection method
     */
    MongoDBProxy.prototype.setupCursorProxy = function (targets, proxyHelper, mongoDBModule) {
        var _this = this;
        var self = this;
        for (var i = 0; i < targets.length; i++) {
            (function (key) {
                function proxy() {
                    return proxyHelper.call(self, key, this, arguments);
                }
                _this.addProxyForCursorMethod(key, proxy, mongoDBModule);
            })(targets[i]);
        }
    };
    /**
     *  helper method to hookup up a proxy method on the mongoDB collection class
     */
    MongoDBProxy.prototype.addProxyForCollectionMethod = function (key, proxy, mongodb) {
        this.realCollectionMethods[key] = mongodb.Collection.prototype[key];
        mongodb.Collection.prototype[key] = proxy;
    };
    ;
    /**
     * helper method to hookup up a proxy method on the mongoDB cursor class
     */
    MongoDBProxy.prototype.addProxyForCursorMethod = function (key, proxy, mongodb) {
        this.realCursorMethods[key] = mongodb.Cursor.prototype[key];
        mongodb.Cursor.prototype[key] = proxy;
    };
    /**
     * helper method to proxy various cursor read statements that support a callback or a promise
     */
    MongoDBProxy.prototype.cursorStartReadProxyCallbackOrPromise = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_READ_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_READ_METHODS, data);
            }
        }
        ;
        function afterFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_READ_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    err: err
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_READ_METHODS, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 0, 1, this.realCursorMethods[methodName], afterSuccess, afterFailure);
    };
    /**
     * helper method to proxy cursor read statements that support only callbacks
     */
    MongoDBProxy.prototype.cursorStartReadProxyCallbackNoPromise = function (methodName, originalThis, originalArgs) {
        if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_START_READ)) {
            var data = {
                originalThis: originalThis,
                methodName: methodName
            };
            Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_START_READ, data);
        }
        // assume args[0] is the callback we need to wrap
        if (typeof (originalArgs[0]) === 'function') {
            var callback_1 = originalArgs[0];
            function callbackWrapper() {
                if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_READ_METHODS)) {
                    var data = {
                        originalThis: originalThis,
                        methodName: methodName,
                        err: undefined
                    };
                    Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_READ_METHODS, data);
                }
                callback_1.apply(this, arguments);
            }
            originalArgs[0] = callbackWrapper;
        }
        return this.realCursorMethods[methodName].apply(originalThis, originalArgs);
    };
    /**
     * Proxy for collection read count
     */
    MongoDBProxy.prototype.collectionReadProxy = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT, data);
            }
        }
        ;
        function afterFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    err: err
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 0, 3, this.realCollectionMethods[methodName], afterSuccess, afterFailure);
    };
    ;
    /**
     *  helper method to proxy various insert methods
     */
    MongoDBProxy.prototype.insertMethodsProxy = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: result,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS, data);
            }
        }
        ;
        function afterFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: undefined,
                    err: err
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 1, 2, this.realCollectionMethods[methodName], afterSuccess, afterFailure);
    };
    ;
    /**
     * Proxy for update methods including 'updateOne', 'updateMany', 'replaceOne', 'findOneAndUpdate'
     */
    MongoDBProxy.prototype.updateProxy = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: result,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS, data);
            }
        }
        ;
        function afterFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: undefined,
                    err: err
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 2, 2, this.realCollectionMethods[methodName], afterSuccess, afterFailure);
    };
    ;
    /**
     *  helper method to proxy deleteOne, deleteMany or findOneAndDelete
     */
    MongoDBProxy.prototype.deleteProxy = function (methodName, originalThis, originalArgs) {
        var startTime = moment();
        var hrtime = process.hrtime();
        function afterDeleteSuccess(result) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: result,
                    err: undefined
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS, data);
            }
        }
        ;
        function afterDeleteFailure(err) {
            if (Tracing_1.default.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS)) {
                var data = {
                    originalThis: originalThis,
                    originalArgs: originalArgs,
                    methodName: methodName,
                    startTime: startTime,
                    hrtime: hrtime,
                    result: undefined,
                    err: err
                };
                Tracing_1.default.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS, data);
            }
        }
        ;
        return this.callbackOrPromise(originalThis, originalArgs, 1, 2, this.realCollectionMethods[methodName], afterDeleteSuccess, afterDeleteFailure);
    };
    ;
    /**
     * helper method that will execute a callback if present, or return a promise.
     *
     * @callbackStartIndex - the string  index into originalArgs of where a callback may be.
     * @callbackProbeLength - the number of slots in originalArgs to probe for a paramater of type function.  This will be the callback.
     * @realMethod - is the actual method that we're proxying.
     * @onSuccess - the callback to raise when @realMethod is successful.
     * @onFailure - the callback to raise when @realMethod fails.
     */
    MongoDBProxy.prototype.callbackOrPromise = function (originalThis, originalArgs, callbackStartIndex, callbackProbeLength, realMethod, onSuccess, onFailure) {
        var originalCallback = undefined;
        var callbackIndex = -1;
        for (var i = callbackStartIndex; i < callbackStartIndex + callbackProbeLength; i++) {
            if (typeof originalArgs[i] === 'function') {
                callbackIndex = i;
                originalCallback = originalArgs[i];
                break;
            }
        }
        if (originalCallback) {
            function callbackWrapper(err, result) {
                if (err) {
                    onFailure(err);
                }
                else {
                    onSuccess(result);
                }
                originalCallback.apply(this, arguments);
            }
            ;
            // replace callback in arguments array
            originalArgs[callbackIndex] = callbackWrapper;
            return realMethod.apply(originalThis, originalArgs);
        }
        else {
            // no callback specified, so we return a promise.
            // this.s.promiseLibrary is a promise constructor.  this.s is Collection's internal state
            function promiseFunction(resolve, reject) {
                function proxySuccess(r) {
                    onSuccess.apply(this, arguments);
                    resolve(r);
                }
                ;
                function proxyFailed(err) {
                    onFailure.apply(this, arguments);
                    reject(err);
                }
                ;
                realMethod.apply(originalThis, originalArgs)
                    .then(proxySuccess, proxyFailed);
            }
            return new originalThis.s.promiseLibrary(promiseFunction);
        }
    };
    ;
    /**
     * Normalizes position of optional options and callback arguments on the given array.
     */
    MongoDBProxy.swizzleArgs = function (argsArray) {
        if (!Array.isArray(argsArray)) {
            argsArray = Array.prototype.slice.call(argsArray, 0);
        }
        if (typeof argsArray[1] === 'function') {
            argsArray.push(argsArray[1]);
            argsArray[1] = {};
        }
        else if (!argsArray[1]) {
            argsArray[1] = {};
        }
        return argsArray;
    };
    /**
     * event names for mongodb
     */
    MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT = 'invoke|pre|module:/mongodb.collection#insert';
    MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS = 'invoke|post|module:/mongodb.collection#insertMethods';
    MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS = 'invoke|post|module:/mongodb.collection#deleteMethods';
    MongoDBProxy.EVENT_MONGODB_READ_METHODS = 'invoke|post|module:/mongodb#readMethods';
    MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS = 'invoke|post|module:/mongodb.collection#updateMethods';
    MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT = 'invoke|post|module:/mongodb.collection#count';
    MongoDBProxy.EVENT_MONGODB_START_READ = 'notify|Module:/mongodb#startRead';
    return MongoDBProxy;
}(ProxyBase_1.ProxyBase));
exports.MongoDBProxy = MongoDBProxy;

//# sourceMappingURL=../../../maps/tracing/proxies/MongoDBProxy.js.map
