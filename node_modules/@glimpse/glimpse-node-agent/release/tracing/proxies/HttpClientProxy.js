'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ProxyBase_1 = require('./ProxyBase');
var uuid_1 = require('uuid');
var Tracing_1 = require('../Tracing');
exports.EVENT_REQUEST_CREATED = 'invoke|post|module:httpClient.request-created';
exports.EVENT_REQUEST_DATA_SENT = 'invoke|pre|module:httpClient.request-data-sent';
exports.EVENT_REQUEST_END = 'invoke|post|module:httpClient.request-end';
exports.EVENT_REQUEST_ERROR = 'notify|module:httpClient.request-error';
exports.EVENT_RESPONSE_RECEIVED = 'notify|module:httpClient.response-received';
exports.EVENT_RESPONSE_DATA_RECEIVED = 'notify|module:httpClient.response-data-received';
exports.EVENT_RESPONSE_END = 'notify|module:httpClient.response-end';
exports.EVENT_RESPONSE_ERROR = 'notify|module:httpClient.response-error';
var HttpClientProxy = (function (_super) {
    __extends(HttpClientProxy, _super);
    function HttpClientProxy() {
        _super.apply(this, arguments);
        this.proxiedModules = [];
    }
    HttpClientProxy.prototype.getModuleNames = function () {
        return ['http'];
    };
    HttpClientProxy.prototype.isEnabledForModule = function (moduleName, configSettings) {
        return this.getModuleNames().indexOf(moduleName) !== -1;
    };
    // Helper methods for publishing events. We break these out into separate
    // methods so we can enforce type checking for the event interfaces
    HttpClientProxy.prototype.publishRequestCreatedEvent = function (data) {
        Tracing_1.default.publish(exports.EVENT_REQUEST_CREATED, data);
    };
    HttpClientProxy.prototype.publishRequestDataSentEvent = function (data) {
        Tracing_1.default.publish(exports.EVENT_REQUEST_DATA_SENT, data);
    };
    HttpClientProxy.prototype.publishRequestEndEvent = function (data) {
        Tracing_1.default.publish(exports.EVENT_REQUEST_END, data);
    };
    HttpClientProxy.prototype.publishRequestErrorEvent = function (data) {
        Tracing_1.default.publish(exports.EVENT_REQUEST_ERROR, data);
    };
    HttpClientProxy.prototype.publishResponseReceivedEvent = function (data) {
        Tracing_1.default.publish(exports.EVENT_RESPONSE_RECEIVED, data);
    };
    HttpClientProxy.prototype.publishResponseDataReceivedEvent = function (data) {
        Tracing_1.default.publish(exports.EVENT_RESPONSE_DATA_RECEIVED, data);
    };
    HttpClientProxy.prototype.publishResponseEndEvent = function (data) {
        Tracing_1.default.publish(exports.EVENT_RESPONSE_END, data);
    };
    HttpClientProxy.prototype.publishResponseErrorEvent = function (data) {
        Tracing_1.default.publish(exports.EVENT_RESPONSE_ERROR, data);
    };
    HttpClientProxy.prototype.init = function (httpModule) {
        if (this.proxiedModules.indexOf(httpModule) !== -1) {
            throw new Error('Cannot proxy a module that has already been proxied');
        }
        this.proxiedModules.push(httpModule);
        var oldRequest = httpModule.request;
        var self = this;
        httpModule.request = function request(options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var req = oldRequest.call.apply(oldRequest, [this, options].concat(requestArgs));
            var id = uuid_1.v1();
            if (Tracing_1.default.isEventEnabled(exports.EVENT_REQUEST_CREATED)) {
                self.publishRequestCreatedEvent({ id: id, req: req, options: options });
            }
            req.on('response', function (res) {
                if (Tracing_1.default.isEventEnabled(exports.EVENT_RESPONSE_RECEIVED)) {
                    self.publishResponseReceivedEvent({ id: id, req: req, res: res });
                }
                res.on('data', function (chunk) {
                    if (Tracing_1.default.isEventEnabled(exports.EVENT_RESPONSE_DATA_RECEIVED)) {
                        self.publishResponseDataReceivedEvent({ id: id, req: req, res: res, chunk: chunk });
                    }
                });
                res.on('end', function () {
                    if (Tracing_1.default.isEventEnabled(exports.EVENT_RESPONSE_END)) {
                        self.publishResponseEndEvent({ id: id, req: req, res: res });
                    }
                });
                res.on('error', function (error) {
                    if (Tracing_1.default.isEventEnabled(exports.EVENT_RESPONSE_ERROR)) {
                        self.publishResponseErrorEvent({ id: id, req: req, res: res, error: error });
                    }
                });
            });
            req.on('error', function (error) {
                if (Tracing_1.default.isEventEnabled(exports.EVENT_REQUEST_ERROR)) {
                    self.publishRequestErrorEvent({ id: id, req: req, error: error });
                }
            });
            // Note: it's possible to write data using the `end` method as well,
            // but that method calls `write` under the hood, and patching both
            // leads to a doubly patched write method, which duplicates the body
            var oldWrite = req.write;
            req.write = function (chunk) {
                var writeArgs = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    writeArgs[_i - 1] = arguments[_i];
                }
                var result = oldWrite.call.apply(oldWrite, [this, chunk].concat(writeArgs));
                if ((typeof chunk === 'string' || Buffer.isBuffer(chunk)) &&
                    Tracing_1.default.isEventEnabled(exports.EVENT_REQUEST_DATA_SENT)) {
                    self.publishRequestDataSentEvent({ id: id, req: req, chunk: chunk });
                }
                return result;
            };
            var oldEnd = req.end;
            req.end = function end() {
                var endArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    endArgs[_i - 0] = arguments[_i];
                }
                var result = oldEnd.apply(this, endArgs);
                if (Tracing_1.default.isEventEnabled(exports.EVENT_REQUEST_END)) {
                    self.publishRequestEndEvent({ id: id, req: req });
                }
                return result;
            };
            return req;
        };
    };
    return HttpClientProxy;
}(ProxyBase_1.ProxyBase));
exports.HttpClientProxy = HttpClientProxy;

//# sourceMappingURL=../../../maps/tracing/proxies/HttpClientProxy.js.map
