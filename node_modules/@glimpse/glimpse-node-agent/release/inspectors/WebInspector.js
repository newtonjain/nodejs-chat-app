'use strict';
var HttpHelper_1 = require('./util/HttpHelper');
var ResponseListener_1 = require('./util/ResponseListener');
var HttpHelper_2 = require('./util/HttpHelper');
var _ = require('lodash');
var InspectorResponseContext = (function () {
    function InspectorResponseContext(startTime) {
        this.startTime = startTime;
        this.headers = {};
    }
    return InspectorResponseContext;
}());
var WebInspector = (function () {
    function WebInspector() {
    }
    WebInspector.prototype.requestStart = function (req, res) {
        var context = HttpHelper_2.HttpHelper.getContext(req);
        if (context) {
            var inspectedResponse_1 = res;
            inspectedResponse_1.__glimpseRequestInspectorContext = new InspectorResponseContext(this.dateTime.now);
            function onHeaders(newHeaders) {
                _.assign(inspectedResponse_1.__glimpseRequestInspectorContext.headers, newHeaders);
            }
            ;
            var responseListener = ResponseListener_1.ResponseListener.attachListener(res);
            responseListener.on(ResponseListener_1.ResponseListener.headersEvent, onHeaders);
        }
    };
    /* tslint:disable:no-any */
    WebInspector.prototype.requestEnd = function (req, res, content, size) {
        /* tslint:enable:no-any */
        // pull context from request instead of context manager, as request/response is more reliable 
        var context = HttpHelper_2.HttpHelper.getContext(req);
        if (context) {
            var inspectedResponse = res;
            // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307
            // Add support for base64 encoding non-text content by setting the encoding here
            var encoding = 'utf8';
            for (var i = 0; i < content.length; i++) {
                if (Buffer.isBuffer(content[i])) {
                    content[i] = content[i].toString();
                }
            }
            var data = {
                protocol: {
                    identifier: HttpHelper_1.RequestHelper.protocol(req),
                    version: req.httpVersion
                },
                url: HttpHelper_1.RequestHelper.protocol(req) + '://' + HttpHelper_1.RequestHelper.host(req) + req.url,
                method: req.method,
                headers: req.headers,
                startTime: inspectedResponse.__glimpseRequestInspectorContext.startTime.format(),
                isAjax: HttpHelper_1.RequestHelper.header(req, '__glimpse-isAjax') === 'true',
                clientIp: req.socket.remoteAddress,
                body: {
                    size: size,
                    encoding: encoding,
                    content: content.join('')
                }
            };
            var indices = {
                'request-url': data.url,
                'request-method': data.method,
                'request-datetime': data.startTime
            };
            var types = ['web-request'];
            this.agent.broker.sendMessage(data, types, indices, context);
        }
    };
    /* tslint:disable:no-any */
    WebInspector.prototype.responseEnd = function (req, res, content, size) {
        /* tslint:enable:no-any */
        // pull context from request instead of context manager, as request/response is more reliable 
        var context = HttpHelper_2.HttpHelper.getContext(req);
        if (context) {
            var inspectedResponse = res;
            var endTime = this.dateTime.now;
            // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307
            // Add support for base64 encoding non-text content by setting the encoding here
            var encoding = 'utf8';
            for (var i = 0; i < content.length; i++) {
                if (Buffer.isBuffer(content[i])) {
                    content[i] = content[i].toString();
                }
            }
            var data = {
                url: HttpHelper_1.RequestHelper.protocol(req) + '://' + HttpHelper_1.RequestHelper.host(req) + req.url,
                headers: inspectedResponse.__glimpseRequestInspectorContext.headers,
                statusCode: res.statusCode,
                duration: endTime.diff(inspectedResponse.__glimpseRequestInspectorContext.startTime),
                endTime: endTime.format(),
                body: {
                    size: size,
                    encoding: encoding,
                    content: content.join('')
                }
            };
            var indices = {
                'request-duration': data.duration,
                'request-status-code': data.statusCode
            };
            var contentType = data.headers['content-type'];
            if (contentType && contentType.length > 0) {
                indices['request-content-type'] = contentType[0];
            }
            var types = ['web-response'];
            this.agent.broker.sendMessage(data, types, indices, context);
        }
    };
    WebInspector.prototype.init = function (agent) {
        this.agent = agent;
        this.dateTime = agent.providers.dateTime;
    };
    return WebInspector;
}());
exports.WebInspector = WebInspector;

//# sourceMappingURL=../../maps/inspectors/WebInspector.js.map
