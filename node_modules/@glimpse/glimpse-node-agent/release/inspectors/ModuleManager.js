'use strict';
var ModuleManager = (function () {
    function ModuleManager() {
        // For the time being, proxies using the new tracing module are kept side-by-side
        // with the old style of proxies. Eventually, everything will be migrated to the
        // new format and this module can be simplified.
        this.proxies = {};
        this.tracingProxies = {};
    }
    ModuleManager.prototype.init = function (agent, module) {
        this.agent = agent;
        this.proxiedModule = module;
        this.originalRequire = module.prototype.require;
        this.setupProxy();
        for (var moduleName in this.proxies) {
            if (this.proxies.hasOwnProperty(moduleName) && this.proxies[moduleName].proxyInstance.forceLoadModule) {
                require(moduleName);
            }
        }
        for (var moduleName in this.tracingProxies) {
            if (!this.tracingProxies.hasOwnProperty(moduleName)) {
                continue;
            }
            for (var _i = 0, _a = this.tracingProxies[moduleName]; _i < _a.length; _i++) {
                var proxy = _a[_i];
                if (proxy.proxyInstance.forceLoadModule) {
                    require(moduleName);
                }
            }
        }
    };
    ;
    ModuleManager.prototype.addProxy = function (proxyInstance, moduleName) {
        moduleName = moduleName || proxyInstance.moduleName;
        this.proxies[moduleName] = {
            proxyInstance: proxyInstance,
            proxiedModule: undefined
        };
        if (this.isInitialized() && proxyInstance.forceLoadModule) {
            require(moduleName);
        }
    };
    ;
    ModuleManager.prototype.addTracingProxy = function (proxyInstance, moduleNames) {
        if (!moduleNames) {
            moduleNames = proxyInstance.getModuleNames();
        }
        for (var _i = 0, moduleNames_1 = moduleNames; _i < moduleNames_1.length; _i++) {
            var moduleName = moduleNames_1[_i];
            if (!this.tracingProxies[moduleName]) {
                this.tracingProxies[moduleName] = [];
            }
            this.tracingProxies[moduleName].push({
                proxyInstance: proxyInstance,
                isInitialized: false
            });
            if (proxyInstance.forceLoadModule) {
                require(moduleName);
            }
        }
    };
    ModuleManager.prototype.isInitialized = function () {
        return (this.agent !== undefined);
    };
    ModuleManager.prototype.setupProxy = function () {
        var self = this;
        var glimpseRequire = function glimpseRequire(id) {
            // _resolveFilename isn't cleanly exposed, but we can access via `this.constructor`.
            // require.resolve(id) doesn't work correctly here since it will run in the context of the Glimpse.Agent
            // module, and not in the context of the module we're trying to load.
            var resolvedPath = this.constructor._resolveFilename(id, this);
            var originalModule = self.originalRequire.call(this, id);
            var overriddenModule;
            if (self.proxies[id] && self.proxies[id].proxyInstance.isEnabledForModule(id, self.agent.providers.configSettings)) {
                if (!self.proxies[id].proxiedModule) {
                    self.proxies[id].proxiedModule = self.proxies[id].proxyInstance.init(self.agent, originalModule, resolvedPath);
                }
                overriddenModule = self.proxies[id].proxiedModule;
            }
            // There are some intersting things going on here with regards to
            // supporting multiple proxies. There are a two competing scenarios
            // that need to be accounted for:
            // 1) The module being proxied assigns a function to module.exports
            //    This function needs to be proxied. This requires that this
            //    function be intercepted and proxied, and the function returned
            //    from requiring that module must be intercepted and overwritten.
            //    This effectively limits this module to a single proxy
            // 2) The module being proxied assigns a number of functions as
            //    properties module.exports. These may be tightly coupled (e.g.
            //    express), or loosely related by category (e.g. http). In both
            //    cases it is not necessary to intercept the object returned
            //    from requiring module, allowing multiple proxies to be loaded
            // To enforce the restriction of a single proxy for 1), but still
            // allow 2), we check the return value from the proxy init method.
            // If it returns something, then this means that proxy is intercepting
            // and overwriting the returned value from requiring the module,
            // indicating we are dealing with case 1). If init does not return
            // a value, this indicates we are dealing with case 2) and allow
            // multiple proxies to init themselves. It is the responsibility
            // of the proxies to ensure they don't step on each other's toes in
            // this case.
            if (self.tracingProxies[id]) {
                for (var _i = 0, _a = self.tracingProxies[id]; _i < _a.length; _i++) {
                    var proxy = _a[_i];
                    if (!proxy.isInitialized && proxy.proxyInstance.isEnabledForModule(id, self.agent.providers.configSettings)) {
                        var newModule = proxy.proxyInstance.init(overriddenModule || originalModule, resolvedPath);
                        if (newModule && overriddenModule) {
                            throw new Error("Only one proxy can override the module.exports object for " + id + " at a time");
                        }
                        overriddenModule = overriddenModule || newModule;
                        proxy.isInitialized = true;
                    }
                }
            }
            return overriddenModule || originalModule;
        };
        this.proxiedModule.prototype.require = glimpseRequire;
    };
    ;
    return ModuleManager;
}());
exports.ModuleManager = ModuleManager;
;

//# sourceMappingURL=../../maps/inspectors/ModuleManager.js.map
