'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ProxyBase_1 = require('./ProxyBase');
var HttpHelper_1 = require('./util/HttpHelper');
var GuidHelper_1 = require('../util/GuidHelper');
var HttpHelper_2 = require('./util/HttpHelper');
// TODO: Expose to configuration
var MAX_BODY_SIZE = 132000;
var SESSION_COOKIE = '.Glimpse.Session';
var ServerProxy = (function () {
    function ServerProxy() {
        this.inspectors = [];
        this.proxiedModules = [];
    }
    /* tslint:disable:no-any */
    ServerProxy.prototype.raiseRequestStartEvent = function (req, res) {
        /* tslint:enable:no-any */
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.requestStart(req, res);
        }
    };
    /* tslint:disable:no-any */
    ServerProxy.prototype.raiseRequestEndEvent = function (req, res, content, size) {
        /* tslint:enable:no-any */
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.requestEnd(req, res, content, size);
        }
    };
    /* tslint:disable:no-any */
    ServerProxy.prototype.raiseResponseEndEvent = function (req, res, content, size) {
        /* tslint:enable:no-any */
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.responseEnd(req, res, content, size);
        }
    };
    ServerProxy.prototype.setupServerProxy = function (agent, httpModule) {
        var oldCreateServer = httpModule.createServer;
        var self = this;
        httpModule.createServer = function createServer(options, cb) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            function internalCallback(req, res) {
                var rest = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    rest[_i - 2] = arguments[_i];
                }
                agent.providers.contextManager.runInNewContext(req, function (context) {
                    // store context on req/response
                    HttpHelper_2.HttpHelper.setContext(req, context);
                    HttpHelper_2.HttpHelper.setContext(res, context);
                    self.raiseRequestStartEvent(req, res);
                    // It is possible in some circumstances that `res.end()` is
                    // called before the `data` event on the `req` object is
                    // fired. In this case, we check this flag and send the before
                    // event immediately before sending the end event.
                    var requestEndSent = false;
                    // Note: the User Inspector class was rolled into this one
                    // because the begin/end events weren't fine graind enough
                    // to set these headers at the appropriate time. Once this
                    // module is ported to the new proxy paradigm, this can be
                    // split back into a separate inspector
                    // BEGIN code from UserInspector
                    var requestCookies = HttpHelper_1.RequestHelper.parseCookies(req);
                    var userId = requestCookies ? requestCookies[SESSION_COOKIE] : undefined;
                    if (!userId) {
                        HttpHelper_1.ResponseHelper.setCookie(res, SESSION_COOKIE, GuidHelper_1.GuidHelper.newGuid(false));
                    }
                    // END code from UserInspector
                    res.setHeader('X-Glimpse-ContextId', context.id);
                    if (cb) {
                        cb.apply(void 0, [req, res].concat(rest));
                    }
                    // General performance note for this implementation: this has been identified
                    // as a hot path for performance, so there are places where maintainability
                    // and readability are sacrificed for performance. Specifically, there is
                    // repeated code in here that could be abstracted into helper methods, but
                    // would incure the extra stack frame and slow things down
                    // Note on Buffers. We use Buffers to store body requests, and we
                    // create new buffers a few times as well. We use the Buffer consructor
                    // to do this for backwards compatibility reasons, but we should
                    // migrate away some day. There is a security risk with using the
                    // Buffer constructor, which is why it's been deprecated. More info:
                    // https://nodejs.org/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe
                    // Chunks may be read back as either Buffers or strings. For now we store
                    // them as an array of chunks, and let inspectors figure out the best way
                    // to normalize them.
                    var requestBodyChunks = [];
                    var requesBodyLength = 0;
                    req.on('data', function (chunk) {
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'data\')', context.id);
                        var originalChunkLength = chunk.length;
                        if (requesBodyLength < MAX_BODY_SIZE) {
                            if (requesBodyLength + originalChunkLength >= MAX_BODY_SIZE) {
                                chunk = chunk.slice(0, MAX_BODY_SIZE - requesBodyLength);
                            }
                            requestBodyChunks.push(chunk);
                        }
                        requesBodyLength += originalChunkLength;
                    });
                    req.on('end', function () {
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        //agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'end\')', context.id);
                        if (!requestEndSent) {
                            self.raiseRequestEndEvent(req, res, requestBodyChunks, requesBodyLength);
                            requestEndSent = true;
                        }
                    });
                    // Note: it's possible to write data using the `end` method as well,
                    // but that method calls `write` under the hood, and patching both
                    // leads to a doubly patched write method, which duplicates the body
                    var responseBodyChunks = [];
                    var responseBodyLength = 0;
                    var oldWrite = res.write;
                    res.write = function (chunk, encoding) {
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        //agent.providers.contextManager.checkContextID('HttpProxy::(response.write())', context.id);
                        var writeArgs = [];
                        for (var _i = 2; _i < arguments.length; _i++) {
                            writeArgs[_i - 2] = arguments[_i];
                        }
                        // Short circuit if we're not actually writing anything
                        if (typeof chunk === 'function' || typeof chunk === 'undefined') {
                            return oldWrite.call.apply(oldWrite, [this, chunk, encoding].concat(writeArgs));
                        }
                        // If we don't have the necessary information to normalize
                        // to a string, the underlying API will throw, so we short
                        // circuit here and call the underlying API
                        if (typeof chunk !== 'string' && !Buffer.isBuffer(chunk)) {
                            return oldWrite.call.apply(oldWrite, [this, chunk, encoding].concat(writeArgs));
                        }
                        // Save part or all of the chunk to the set of chunks,
                        // truncating if necessary to keep the set under the
                        // max body size
                        var originalChunkLength = chunk.length;
                        var normalizedChunk = chunk;
                        if (responseBodyLength < MAX_BODY_SIZE) {
                            if (responseBodyLength + originalChunkLength >= MAX_BODY_SIZE) {
                                normalizedChunk = normalizedChunk.slice(0, MAX_BODY_SIZE - responseBodyLength);
                            }
                            responseBodyChunks.push(normalizedChunk);
                        }
                        responseBodyLength += originalChunkLength;
                        return oldWrite.call.apply(oldWrite, [this, chunk, encoding].concat(writeArgs));
                    };
                    res.on('finish', function () {
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        //agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'finish\')', context.id);
                        if (!requestEndSent) {
                            // If we got here, it means that the `res.end()` method
                            // was called before the body was received (if any). User's
                            // will often do this if returning an error status, or
                            // if they know there isn't a body associated with this
                            // request, so we report the body as not existing
                            self.raiseRequestEndEvent(req, res, [], 0);
                            requestEndSent = true;
                        }
                        self.raiseResponseEndEvent(req, res, responseBodyChunks, responseBodyLength);
                    });
                });
            }
            ;
            // Note: https.createServer and http.createServer have different signatures:
            // http.createServer([callback])
            // https.createServer(options[, callback])
            // We can't inspect the callback type because the callback is optional,
            // but we can inspect the `options` parameter since it is required for
            // HTTPS calls and HTTP calls don't accept an options object
            if (typeof options !== 'object') {
                cb = options;
                return oldCreateServer.call.apply(oldCreateServer, [this, internalCallback].concat(args));
            }
            else {
                return oldCreateServer.call.apply(oldCreateServer, [this, options, internalCallback].concat(args));
            }
        };
    };
    ServerProxy.prototype.setupInspectorExtensions = function (agent) {
        for (var _i = 0, _a = this.inspectors; _i < _a.length; _i++) {
            var inspector = _a[_i];
            inspector.init(agent);
        }
    };
    ServerProxy.prototype.addInspector = function (inspector) {
        if (this.proxiedModules.length) {
            throw new Error('Cannot add inspectors after the proxy has been initialized for the first time');
        }
        this.inspectors.push(inspector);
    };
    ServerProxy.prototype.init = function (agent, httpModule) {
        this.agent = agent;
        // We can only initialize the proxies once, otherwise we will get n
        // copies of all messages because the proxies will nest inside each other
        if (this.proxiedModules.indexOf(httpModule) !== -1) {
            throw new Error('Cannot proxy a module that has already been proxied');
        }
        this.proxiedModules.push(httpModule);
        this.setupServerProxy(agent, httpModule);
        this.setupInspectorExtensions(agent);
        return httpModule;
    };
    ;
    return ServerProxy;
}());
var HttpProxy = (function (_super) {
    __extends(HttpProxy, _super);
    function HttpProxy() {
        _super.apply(this, arguments);
        this.serverProxy = new ServerProxy();
    }
    Object.defineProperty(HttpProxy.prototype, "moduleName", {
        get: function () { return 'http'; },
        enumerable: true,
        configurable: true
    });
    ;
    HttpProxy.prototype.addServerInspector = function (inspector) {
        this.serverProxy.addInspector(inspector);
    };
    HttpProxy.prototype.init = function (agent, httpModule, resolvedName) {
        this.serverProxy.init(agent, httpModule);
        return httpModule;
    };
    ;
    Object.defineProperty(HttpProxy.prototype, "forceLoadModule", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    return HttpProxy;
}(ProxyBase_1.ProxyBase));
exports.HttpProxy = HttpProxy;

//# sourceMappingURL=../../maps/inspectors/HttpProxy.js.map
