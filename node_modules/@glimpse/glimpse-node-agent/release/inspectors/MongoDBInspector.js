'use strict';
var MongoDBProxy_1 = require('../tracing/proxies/MongoDBProxy');
var DateTimeValue_1 = require('../configuration/DateTimeValue');
var Tracing_1 = require('../tracing/Tracing');
var _ = require('lodash');
/**
 * Class that represents a set of data that we pass along as part of the "options"
 * parameter to various MongoDB calls. This lets us pass data between multiple proxy calls on the
 * same call stack or call chain.
 */
var GlimpseMongoDBOptions = (function () {
    function GlimpseMongoDBOptions() {
        this._messageSent = false;
    }
    Object.defineProperty(GlimpseMongoDBOptions.prototype, "operationName", {
        /**
         * Get the operation name
         */
        get: function () {
            return this._operationName;
        },
        /**
         * Set the primary operation name for this call chain.  This is what is shown in the custom message.
         */
        set: function (name) {
            this._operationName = name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GlimpseMongoDBOptions.prototype, "messageSent", {
        /**
         * Get if message is sent
         */
        get: function () {
            return this._messageSent;
        },
        /**
         * Record that message is sent
         */
        set: function (sent) {
            this._messageSent = sent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return the GlimpseMongoDBOptions instance from the given object, or return undefined if not available.
     */
    GlimpseMongoDBOptions.get = function (options) {
        var gopts;
        if (options) {
            gopts = options[GlimpseMongoDBOptions.CUSTOM_KEY];
        }
        return gopts;
    };
    /**
     * Remove the GlimpseMongoDBOptions instance from the given object
     */
    GlimpseMongoDBOptions.clear = function (options) {
        if (options && options[GlimpseMongoDBOptions.CUSTOM_KEY]) {
            delete options[GlimpseMongoDBOptions.CUSTOM_KEY];
        }
    };
    /**
     *  Ensure the GlimpseMongoDBOptions instance exists on the given object, and return it.
     */
    GlimpseMongoDBOptions.ensure = function (options) {
        var gopts = options[GlimpseMongoDBOptions.CUSTOM_KEY];
        if (!gopts) {
            gopts = new GlimpseMongoDBOptions();
            options[GlimpseMongoDBOptions.CUSTOM_KEY] = gopts;
        }
        return gopts;
    };
    GlimpseMongoDBOptions.CUSTOM_KEY = '__customOptions';
    return GlimpseMongoDBOptions;
}());
exports.GlimpseMongoDBOptions = GlimpseMongoDBOptions;
var MongoDBInspector = (function () {
    function MongoDBInspector() {
    }
    MongoDBInspector.prototype.init = function (agent) {
        var _this = this;
        this.agent = agent;
        this.contextManager = agent.providers.contextManager;
        Tracing_1.default.onAlways(MongoDBProxy_1.MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT, function (event) {
            _this.insertInspector(event);
        });
        Tracing_1.default.onAlways(MongoDBProxy_1.MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS, function (event) {
            _this.insertMethodsInspector(event);
        });
        Tracing_1.default.onAlways(MongoDBProxy_1.MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS, function (event) {
            _this.updateMethodsInspector(event);
        });
        Tracing_1.default.onAlways(MongoDBProxy_1.MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT, function (event) {
            _this.countInspector(event);
        });
        Tracing_1.default.onAlways(MongoDBProxy_1.MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS, function (event) {
            _this.deleteMethodsInspector(event);
        });
        Tracing_1.default.onAlways(MongoDBProxy_1.MongoDBProxy.EVENT_MONGODB_READ_METHODS, function (event) {
            _this.readCompletedInspector(event);
        });
        Tracing_1.default.onAlways(MongoDBProxy_1.MongoDBProxy.EVENT_MONGODB_START_READ, function (event) {
            _this.readStartInspector(event);
        });
    };
    ;
    /**
     *  sendAfterReadMessage
     */
    MongoDBInspector.prototype.sendAfterReadMessage = function (err, operation, startTime, query, options, ci) {
        var context = this.contextManager.currentContext();
        if (context) {
            var endTime = this.agent.providers.dateTime.now;
            this.agent.broker.sendMessage({
                operation: operation,
                query: query,
                startTime: startTime.format(),
                duration: endTime.diff(startTime),
                options: options,
                connectionHost: ci.host,
                connectionPort: ci.port,
                database: ci.database,
                collection: ci.collectionName
            }, ['data-mongodb-read']);
        }
    };
    ;
    /**
     *  sendAfterInsertMessage
     */
    MongoDBInspector.prototype.sendAfterInsertMessage = function (err, operation, startTime, docs, numInserted, insertedIDs, options, ci) {
        var context = this.contextManager.currentContext();
        if (context) {
            var endTime = this.agent.providers.dateTime.now;
            this.agent.broker.sendMessage({
                operation: operation,
                docs: docs,
                count: numInserted,
                insertedIds: insertedIDs,
                startTime: startTime.format(),
                duration: endTime.diff(startTime),
                options: options,
                connectionHost: ci.host,
                connectionPort: ci.port,
                database: ci.database,
                collection: ci.collectionName
            }, ['data-mongodb-insert']);
        }
    };
    ;
    /**
     * method to send an update completed message
     */
    MongoDBInspector.prototype.sendAfterUpdateMessage = function (err, operation, startTime, query, updates, matchedCount, modifiedCount, upsertedCount, options, ci) {
        var context = this.contextManager.currentContext();
        if (context) {
            var endTime = this.agent.providers.dateTime.now;
            this.agent.broker.sendMessage({
                operation: operation,
                query: query,
                updates: updates,
                matchedCount: matchedCount,
                modifiedCount: modifiedCount,
                upsertedCount: upsertedCount,
                startTime: startTime.format(),
                duration: endTime.diff(startTime),
                options: options,
                connectionHost: ci.host,
                connectionPort: ci.port,
                database: ci.database,
                collection: ci.collectionName
            }, ['data-mongodb-update']);
        }
    };
    ;
    /**
     * method to send a delete completed message.
     */
    MongoDBInspector.prototype.sendAfterDeleteMessage = function (err, operation, startTime, query, numDeleted, options, ci) {
        var context = this.contextManager.currentContext();
        if (context) {
            var endTime = this.agent.providers.dateTime.now;
            this.agent.broker.sendMessage({
                operation: operation,
                query: query,
                count: numDeleted,
                startTime: startTime.format(),
                duration: endTime.diff(startTime),
                options: options,
                connectionHost: ci.host,
                connectionPort: ci.port,
                database: ci.database,
                collection: ci.collectionName
            }, ['data-mongodb-delete']);
        }
    };
    ;
    /**
     * Handle insert method
     */
    MongoDBInspector.prototype.insertInspector = function (event) {
        // since insert implementation calls back in on insertMany, we need to override the operation name used
        GlimpseMongoDBOptions.ensure(event.data.originalArgs[1]).operationName = 'insert';
    };
    ;
    /**
     * Notify insert methods including 'insertMany' and 'insertOne'
     */
    MongoDBInspector.prototype.insertMethodsInspector = function (event) {
        var connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(event.data.originalThis);
        var docs = event.data.originalArgs[0];
        var options = event.data.originalArgs[1];
        var methodName = event.data.methodName;
        var count = 0;
        var insertedIDs = [];
        var result = event.data.result;
        if (typeof options === 'function') {
            options = undefined;
        }
        var operationName = methodName;
        var opts = GlimpseMongoDBOptions.get(options);
        if (opts) {
            if (opts.operationName) {
                operationName = opts.operationName;
            }
            // strip out the custom options as they're no longer necessary
            GlimpseMongoDBOptions.clear(options);
        }
        if (!options) {
            options = {};
        }
        else {
            // strip out the custom options as they're no longer necessary
            GlimpseMongoDBOptions.clear(options);
            options = _.cloneDeep(options);
            // strip out checkKeys as Mongo adds this
            options.checkKeys = undefined;
        }
        if (methodName === 'insertOne') {
            docs = [docs];
        }
        if (!event.data.err) {
            if (methodName === 'insertOne') {
                if (result) {
                    count = result.ops.length;
                    insertedIDs = [result.insertedId];
                }
            }
            else {
                if (result) {
                    count = result.insertedCount;
                    insertedIDs = result.insertedIds;
                }
            }
        }
        this.sendAfterInsertMessage(event.data.err, operationName, DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime), docs, count, insertedIDs, options, connectionInfo);
    };
    ;
    /**
     * Notify delete methods including 'deleteMany', 'deleteOne', 'findOneAndDelete', 'remove'
     */
    MongoDBInspector.prototype.deleteMethodsInspector = function (event) {
        var originalArgs = event.data.originalArgs;
        var filter = originalArgs[0];
        var options = originalArgs[1];
        var connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(event.data.originalThis);
        var count = 0;
        var result = event.data.result;
        var methodName = event.data.methodName;
        if (typeof options === 'function') {
            options = undefined;
        }
        if (!options) {
            options = {};
        }
        else {
            GlimpseMongoDBOptions.clear(options);
            options = _.cloneDeep(options);
        }
        if (result) {
            if (methodName === 'findOneAndDelete') {
                if (result.value) {
                    count = 1;
                }
            }
            else if (methodName === 'remove') {
                if (result.result) {
                    count = result.result.n;
                }
            }
            else {
                count = result.deletedCount;
            }
        }
        this.sendAfterDeleteMessage(event.data.err, methodName, DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime), filter, count, options, connectionInfo);
    };
    ;
    /**
     * Notify update operation
     */
    MongoDBInspector.prototype.updateMethodsInspector = function (event) {
        var connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(event.data.originalThis);
        var originalArgs = event.data.originalArgs;
        var result = event.data.result;
        var methodName = event.data.methodName;
        var filter = originalArgs[0];
        var update = originalArgs[1];
        var options = originalArgs[2];
        var matchedCount = 0;
        var modifiedCount = 0;
        var upsertedCount = 0;
        if (typeof options === 'function') {
            options = undefined;
        }
        if (!options) {
            options = {};
        }
        else {
            // strip out the custom options as they're no longer necessary
            GlimpseMongoDBOptions.clear(options);
            options = _.cloneDeep(options);
        }
        if (result) {
            matchedCount = result.matchedCount;
            modifiedCount = result.modifiedCount;
            upsertedCount = result.upsertedCount;
            if (methodName === 'findOneAndUpdate') {
                if (result.lastErrorObject.updatedExisting) {
                    upsertedCount = 0;
                    matchedCount = 1;
                    modifiedCount = 1;
                }
                else if (result.lastErrorObject.n > 0) {
                    upsertedCount = 1;
                    matchedCount = 1;
                    modifiedCount = 0;
                }
                else {
                    upsertedCount = 0;
                    matchedCount = 0;
                    modifiedCount = 0;
                }
            }
        }
        this.sendAfterUpdateMessage(event.data.err, event.data.methodName, DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime), filter, update, matchedCount, modifiedCount, upsertedCount, options, connectionInfo);
    };
    ;
    /**
     *  Inspect collection read count
     */
    MongoDBInspector.prototype.countInspector = function (event) {
        var originalThis = event.data.originalThis;
        var originalArgs = event.data.originalArgs;
        var connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(originalThis);
        var query = originalArgs[0];
        var options = event.data.originalArgs[1];
        if (typeof options === 'function') {
            options = undefined;
        }
        if (!options) {
            options = {};
        }
        this.sendAfterReadMessage(event.data.err, event.data.methodName, DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime), query, options, connectionInfo);
    };
    ;
    /*
     * Record the operation name for read operations
     */
    MongoDBInspector.prototype.readStartInspector = function (event) {
        var originalThis = event.data.originalThis;
        var cursorCustomOpts = GlimpseMongoDBOptions.ensure(originalThis.s.cmd);
        if (!cursorCustomOpts.operationName) {
            cursorCustomOpts.operationName = event.data.methodName;
        }
    };
    /**
     * Notify read operations
     */
    MongoDBInspector.prototype.readCompletedInspector = function (event) {
        var originalThis = event.data.originalThis;
        var connectionInfo = MongoDBInspector.GetConnectionInfoFromCursor(originalThis);
        var operationName = event.data.methodName;
        var cursorCustomOpts = GlimpseMongoDBOptions.ensure(originalThis.s.cmd);
        if (cursorCustomOpts.operationName) {
            operationName = cursorCustomOpts.operationName;
        }
        if (!cursorCustomOpts.messageSent) {
            cursorCustomOpts.messageSent = true;
            // clone options & clear out Glimpse opts so we don't include them in Glimpse messages
            var opts = _.cloneDeep(originalThis.s.cmd);
            GlimpseMongoDBOptions.clear(opts);
            this.sendAfterReadMessage(event.data.err, operationName, DateTimeValue_1.DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime), originalThis.s.cmd.query, opts, connectionInfo);
        }
    };
    /**
     * method to extract connection info details from a MongoDB Cusror istance
     */
    MongoDBInspector.GetConnectionInfoFromCursor = function (cursor) {
        var dbname = cursor.options.db.s.databaseName;
        return {
            host: cursor.topology.s.serverDetails.host,
            port: cursor.topology.s.serverDetails.port,
            database: dbname,
            collectionName: cursor.ns.substring(dbname.length + 1)
        };
    };
    /**
     * method to extract connection info details from a MongoDB Collection istance
     */
    MongoDBInspector.GetConnectionInfoFromCollection = function (collection) {
        return {
            host: collection.s.topology.s.host,
            port: collection.s.topology.s.port,
            database: collection.s.dbName,
            collectionName: collection.s.name
        };
    };
    return MongoDBInspector;
}());
exports.MongoDBInspector = MongoDBInspector;

//# sourceMappingURL=../../maps/inspectors/MongoDBInspector.js.map
