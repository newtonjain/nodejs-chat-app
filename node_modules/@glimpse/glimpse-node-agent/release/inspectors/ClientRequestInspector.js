'use strict';
var DateTimeValue_1 = require('../configuration/DateTimeValue');
var Tracing_1 = require('../tracing/Tracing');
var HttpClientProxy = require('../tracing/proxies/HttpClientProxy');
var HttpHelper_1 = require('./util/HttpHelper');
var url = require('url');
var _ = require('lodash');
// TODO: move this to a global config object
var MAX_BODY_SIZE = 132000;
var ClientRequestInspector = (function () {
    function ClientRequestInspector() {
        this.requests = {};
    }
    ClientRequestInspector.prototype.normalizeOptions = function (options, req) {
        // Normalize to a copy of the original options
        if (typeof options === 'string') {
            options = url.parse(options);
        }
        options = _.assign({}, options);
        // Oddly, url.format ignores path and only uses pathname and search,
        // so create them from the path, if path was specified
        if (options.path) {
            var parsedQuery = url.parse(options.path);
            options.pathname = parsedQuery.pathname;
            options.search = parsedQuery.search;
        }
        // Simiarly, url.format ignores hostname and path if host is specified,
        // even if host doesn't have the port, but http.request does not work
        // this way. It will use the port if one is not specified in host,
        // effectively treating host as hostname, but will use the port specified
        // in host if it exists. Fun times.
        if (options.host && options.port) {
            // Force a protocol so it will parse the host as the host, not path.
            // It is discarded and not used, so it doesn't matter if it doesn't match
            var parsedHost = url.parse("http://" + options.host);
            if (!parsedHost.port && options.port) {
                options.hostname = options.host;
                delete options.host;
            }
        }
        // Mix in default values used by http.request and others
        options.protocol = options.protocol || req.agent.protocol;
        options.hostname = options.hostname || 'localhost';
        return options;
    };
    ClientRequestInspector.prototype.numOutstandingRequests = function () {
        return Object.keys(this.requests).length;
    };
    ClientRequestInspector.prototype.before = function (options, req, content, size, startTimeStamp) {
        // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307
        // Add support for base64 encoding non-text content by setting the encoding here
        var encoding = 'utf8';
        for (var i = 0; i < content.length; i++) {
            if (Buffer.isBuffer(content[i])) {
                content[i] = content[i].toString();
            }
        }
        var payload = {
            protocol: {
                identifier: options.protocol.replace(':', '').toUpperCase(),
                // This value is hard coded in Node: https://github.com/nodejs/node/blob/d0582ef9e19e8ed941b0a585c935ad11919080ee/lib/_http_client.js#L114
                version: '1.1'
            },
            url: url.format(options),
            method: req.method,
            startTime: startTimeStamp,
            // Note: this uses a private field on the request object. Sadly, there isn't another way to get these currently.
            headers: req._headers,
            isAjax: false,
            clientIp: '127.0.0.1',
            body: {
                size: size,
                encoding: encoding,
                content: content.join(''),
                isTruncated: size > content.length
            }
        };
        this.agent.broker.sendMessage(payload, ['data-http-request'], undefined, HttpHelper_1.HttpHelper.getContext(req));
    };
    ClientRequestInspector.prototype.after = function (options, res, content, size, endTimeStamp, duration) {
        // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307
        // Add support for base64 encoding non-text content by setting the encoding here
        var encoding = 'utf8';
        for (var i = 0; i < content.length; i++) {
            if (Buffer.isBuffer(content[i])) {
                content[i] = content[i].toString();
            }
        }
        var payload = {
            // res.url doesn't seem to be populated in practice
            url: res.url || url.format(options),
            headers: res.headers,
            statusCode: res.statusCode,
            endTime: endTimeStamp,
            duration: duration,
            body: {
                size: size,
                encoding: encoding,
                content: content.join(''),
                isTruncated: size > content.length
            }
        };
        this.agent.broker.sendMessage(payload, ['data-http-response'], undefined, HttpHelper_1.HttpHelper.getContext(res));
    };
    ClientRequestInspector.prototype.init = function (agent) {
        var _this = this;
        this.agent = agent;
        Tracing_1.default.onAlways(HttpClientProxy.EVENT_REQUEST_CREATED, function (event) { return _this.onRequestCreated(event); });
        Tracing_1.default.onAlways(HttpClientProxy.EVENT_REQUEST_DATA_SENT, function (event) { return _this.onRequestDataSent(event); });
        Tracing_1.default.onAlways(HttpClientProxy.EVENT_REQUEST_END, function (event) { return _this.onRequestEnd(event); });
        Tracing_1.default.onAlways(HttpClientProxy.EVENT_REQUEST_ERROR, function (event) { return _this.onRequestError(event); });
        Tracing_1.default.onAlways(HttpClientProxy.EVENT_RESPONSE_DATA_RECEIVED, function (event) { return _this.onResponseDataReceived(event); });
        Tracing_1.default.onAlways(HttpClientProxy.EVENT_RESPONSE_END, function (event) { return _this.onResponseEnd(event); });
        Tracing_1.default.onAlways(HttpClientProxy.EVENT_RESPONSE_ERROR, function (event) { return _this.onResponseError(event); });
    };
    ClientRequestInspector.prototype.onRequestCreated = function (event) {
        var eventData = event.data;
        this.requests[eventData.id] = {
            startTime: event.time,
            startTimeStamp: DateTimeValue_1.DateTimeValue.fromUnixMillisecondTimestamp(event.timestamp, event.time).format(),
            options: this.normalizeOptions(eventData.options, eventData.req),
            requestBodyChunks: [],
            requestBodyLength: 0,
            responseBodyChunks: [],
            responseBodyLength: 0
        };
    };
    ClientRequestInspector.prototype.onRequestDataSent = function (event) {
        var eventData = event.data;
        var masterData = this.requests[eventData.id];
        if (!masterData) {
            throw new Error('Internal error: could not find associated master data');
        }
        // Save part or all of the chunk to the set of chunks,
        // truncating if necessary to keep the set under the
        // max body size
        var originalChunkLength = eventData.chunk.length;
        var normalizedChunk = eventData.chunk;
        if (masterData.requestBodyLength < MAX_BODY_SIZE) {
            if (masterData.requestBodyLength + originalChunkLength >= MAX_BODY_SIZE) {
                normalizedChunk = normalizedChunk.slice(0, MAX_BODY_SIZE - masterData.requestBodyLength);
            }
            masterData.requestBodyChunks.push(normalizedChunk);
        }
        masterData.requestBodyLength += originalChunkLength;
    };
    ClientRequestInspector.prototype.onRequestEnd = function (event) {
        var eventData = event.data;
        var masterData = this.requests[eventData.id];
        if (!masterData) {
            throw new Error('Internal error: could not find associated master data');
        }
        this.before(masterData.options, eventData.req, masterData.requestBodyChunks, masterData.requestBodyLength, masterData.startTimeStamp);
    };
    ClientRequestInspector.prototype.onRequestError = function (event) {
        var eventData = event.data;
        var masterData = this.requests[eventData.id];
        if (!masterData) {
            throw new Error('Internal error: could not find associated master data');
        }
        delete this.requests[eventData.id];
    };
    ClientRequestInspector.prototype.onResponseDataReceived = function (event) {
        var eventData = event.data;
        var masterData = this.requests[eventData.id];
        if (!masterData) {
            throw new Error('Internal error: could not find associated master data');
        }
        // Save part or all of the chunk to the set of chunks,
        // truncating if necessary to keep the set under the
        // max body size
        var originalChunkLength = eventData.chunk.length;
        var normalizedChunk = eventData.chunk;
        if (masterData.responseBodyLength < MAX_BODY_SIZE) {
            if (masterData.responseBodyLength + originalChunkLength >= MAX_BODY_SIZE) {
                normalizedChunk = normalizedChunk.slice(0, MAX_BODY_SIZE - masterData.responseBodyLength);
            }
            masterData.responseBodyChunks.push(normalizedChunk);
        }
        masterData.responseBodyLength += originalChunkLength;
    };
    ClientRequestInspector.prototype.onResponseEnd = function (event) {
        var eventData = event.data;
        var masterData = this.requests[eventData.id];
        if (!masterData) {
            throw new Error('Internal error: could not find associated master data');
        }
        var duration = (event.time[0] * 1e9 + event.time[1] -
            masterData.startTime[0] * 1e9 - masterData.startTime[1]) / 1e6;
        this.after(masterData.options, eventData.res, masterData.responseBodyChunks, masterData.responseBodyLength, DateTimeValue_1.DateTimeValue.fromUnixMillisecondTimestamp(event.timestamp, event.time).format(), duration);
        delete this.requests[eventData.id];
    };
    ClientRequestInspector.prototype.onResponseError = function (event) {
        var eventData = event.data;
        var masterData = this.requests[eventData.id];
        if (!masterData) {
            throw new Error('Internal error: could not find associated master data');
        }
        delete this.requests[eventData.id];
    };
    return ClientRequestInspector;
}());
exports.ClientRequestInspector = ClientRequestInspector;

//# sourceMappingURL=../../maps/inspectors/ClientRequestInspector.js.map
