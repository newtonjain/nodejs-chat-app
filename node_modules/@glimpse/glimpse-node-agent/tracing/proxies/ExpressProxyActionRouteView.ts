'use strict';

import { ExpressProxy } from './ExpressProxy';
import Tracing from './../Tracing';

export class ExpressProxyActionRouteView {

    public static init(express) {

        const expressDispatch = express.Route.prototype.dispatch;
        express.Route.prototype.dispatch = function dispatchRoute() {

            if (Tracing.isEventEnabled(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_ROUTE_DISPATCH)) {
                const data = {
                    originalThis: this,
                    originalArgs: arguments
                };
                Tracing.publish(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_ROUTE_DISPATCH, data);
            }

            expressDispatch.apply(this, arguments);
        };

        function viewRender() {
            if (Tracing.isEventEnabled(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_VIEW_RENDER)) {
                const data = {
                    originalThis: this,
                    originalArgs: arguments
                };
                Tracing.publish(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_VIEW_RENDER, data);
            }
            const expressViewRender = this.originalRender;
            expressViewRender.apply(this, arguments);
        };

        const expressResponseRender = express.response.render;
        express.response.render = function renderResponse(...rest) {
            // Need to pass original arguments
            const updatedArguments = ExpressProxyActionRouteView.fixupResponseRenderArgs(this, rest);

            // hijack the view render here - A "view engine" is pluggable on the app, so we want to support
            // potential of multiple apps in a process with different "view" settings.
            if (!this.req.app.settings.view.prototype.originalRender) {
                this.req.app.settings.view.prototype.originalRender = this.req.app.settings.view.prototype.render;
                this.req.app.settings.view.prototype.render = viewRender;
            }

            if (Tracing.isEventEnabled(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_RESPONSE_RENDER)) {
                const data = {
                    originalThis: this,
                    originalArgs: updatedArguments
                };
                Tracing.publish(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_RESPONSE_RENDER, data);
            }

            expressResponseRender.apply(this, updatedArguments);
        };

        const expressSend = express.response.send;
        express.response.send = function sendResponse() {
            if (Tracing.isEventEnabled(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_RESPONSE_SEND)) {
                const data = {
                    originalThis: this,
                    originalArgs: arguments
                };
                Tracing.publish(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_RESPONSE_SEND, data);
            }

            expressSend.apply(this, arguments);
        };

        const expressEnd = express.response.end;
        express.response.end = function endResponse() {

            if (Tracing.isEventEnabled(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_RESPONSE_END)) {
                const data = {
                    originalThis: this,
                    originalArgs: arguments
                };
                Tracing.publish(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_RESPONSE_END, data);
            }

            expressEnd.apply(this, arguments);
        };
    }

    private static fixupResponseRenderArgs(response, originalArguments) {
        let done;

        function onRenderComplete(err, str) {

            if (Tracing.isEventEnabled(ExpressProxy.EVENT_NOTIFY_EXPRESS_RENDER_COMPLETE)) {
                const data = {
                    originalThis: this,
                    originalArgs: arguments,
                    err: err
                };
                Tracing.publish(ExpressProxy.EVENT_NOTIFY_EXPRESS_RENDER_COMPLETE, data);
            }

            done(err, str);
        };

        const updatedArguments = Array.prototype.slice.call(originalArguments);

        if (updatedArguments.length > 0 && (typeof updatedArguments[updatedArguments.length - 1] === 'function')) {
            done = updatedArguments[updatedArguments.length - 1];
            updatedArguments[updatedArguments.length - 1] = onRenderComplete;
        }
        else {
            updatedArguments.push(onRenderComplete);
        }

        // default callback - this is the default "done" handler set up by express response object.  It ensures we have correct error handling. 
        done = done || function (err, str) {
            if (err) {
                return response.req.next(err);
            }
            response.send(str);
        };

        return updatedArguments;
    }
}
