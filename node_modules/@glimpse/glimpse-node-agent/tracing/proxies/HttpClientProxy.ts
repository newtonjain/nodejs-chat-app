'use strict';

import { ProxyBase } from './ProxyBase';
import { IConfigSettings } from '../../configuration/IConfigSettings';
import { v1 as generateUUID } from 'uuid';
import { ClientRequest, IncomingMessage } from 'http';
import tracing from '../Tracing';

/**
 * This event indicates that a request was created via a call to `http.request()`.
 * This event does *not* indicate that the request was sent, nor that headers are
 * ready to be read, that happens in `IRequestEndEvent`.
 *
 * @property {string} id - An ID that is consistent for all stages of this request
 * @property {ClientRequest} req - The client request object returned from `http.request`
 * @property {object} options - The options passed to `http.request`
 */
export interface IRequestCreatedEvent {
    id: string;
    req: ClientRequest;
    options;
}
export const EVENT_REQUEST_CREATED = 'invoke|post|module:httpClient.request-created';

/**
 * This event indicates that request data was sent to the remote server. This may have
 * occured because of a `req.write` call or a `req.end` call.
 *
 * @property {string} id - An ID that is consistent for all stages of this request
 * @property {ClientRequest} req - The client request object returned from `http.request`
 * @proprety {Buffer|String} chunk - The data chunk written to the remote server
 */
export interface IRequestDataSentEvent {
    id: string;
    req: ClientRequest;
    chunk: Buffer | string;
}
export const EVENT_REQUEST_DATA_SENT = 'invoke|pre|module:httpClient.request-data-sent';

/**
 * This event indicates that the request was finalized. No more data may be written
 * after this event, and it is now possible to read the final headers for the request
 *
 * @property {string} id - An ID that is consistent for all stages of this request
 * @property {ClientRequest} req - The client request object returned from `http.request`
 */
export interface IRequestEndEvent {
    id: string;
    req: ClientRequest;
}
export const EVENT_REQUEST_END = 'invoke|post|module:httpClient.request-end';

/**
 * This event indicates that there was an error completing the request. Note,
 * this event will not be emitted after the `REQUEST_END_EVENT` is emitted.
 * Further errors will be emitted as `EVENT_RESPONSE_ERROR`
 *
 * @property {string} id - An ID that is consistent for all stages of this request
 * @property {ClientRequest} req - The client request object returned from `http.request`
 * @property {Error|string} error - The error that occured
 */
export interface IRequestErrorEvent {
    id: string;
    req: ClientRequest;
    error: Error | string;
}
export const EVENT_REQUEST_ERROR = 'notify|module:httpClient.request-error';

/**
 * This event indicates that headers for the response have been received. Any response data
 * will come after this event in an `IResponseDataReceivedEvent` event.
 *
 * @property {string} id - An ID that is consistent for all stages of this request
 * @property {ClientRequest} req - The client request object returned from `http.request`
 * @property {IncomingMessage} res - The incoming response from the remote server, as passed
 *      to the `response` event.
 */
export interface IResponseReceivedEvent {
    id: string;
    req: ClientRequest;
    res: IncomingMessage;
}
export const EVENT_RESPONSE_RECEIVED = 'notify|module:httpClient.response-received';

/**
 * This event indicates that data was recieved from the remote server.
 *
 * @property {string} id - An ID that is consistent for all stages of this request
 * @property {ClientRequest} req - The client request object returned from `http.request`
 * @property {IncomingMessage} res - The incoming response from the remote server, as passed
 * @proprety {Buffer|String} chunk - The data chunk received from the remote server
 *      to the `response` event.
 */
export interface IResponseDataReceivedEvent {
    id: string;
    req: ClientRequest;
    res: IncomingMessage;
    chunk: Buffer | string;
}
export const EVENT_RESPONSE_DATA_RECEIVED = 'notify|module:httpClient.response-data-received';

/**
 * This event indicates the response has ended and the client request has finished.
 *
 * @property {string} id - An ID that is consistent for all stages of this request
 * @property {ClientRequest} req - The client request object returned from `http.request`
 * @property {IncomingMessage} res - The incoming response from the remote server, as passed
 */
export interface IResponseEndEvent {
    id: string;
    req: ClientRequest;
    res: IncomingMessage;
}
export const EVENT_RESPONSE_END = 'notify|module:httpClient.response-end';

/**
 * This event indicates that there was an error completing the response. Note:
 * this event will not be emitted before `EVENT_RESPONSE_RECEIVED`
 *
 * @property {string} id - An ID that is consistent for all stages of this request
 * @property {ClientRequest} req - The client request object returned from `http.request`
 * @property {IncomingMessage} res - The incoming response from the remote server, as passed
 * @property {Error|string} error - The error that occured
 */
export interface IResponseErrorEvent {
    id: string;
    req: ClientRequest;
    res: IncomingMessage;
    error: Error | string;
}
export const EVENT_RESPONSE_ERROR = 'notify|module:httpClient.response-error';

export class HttpClientProxy extends ProxyBase {

    private proxiedModules = [];

    public getModuleNames() {
        return [ 'http' ];
    }

    public isEnabledForModule(moduleName: string, configSettings: IConfigSettings): boolean {
        return this.getModuleNames().indexOf(moduleName) !== -1;
    }

    // Helper methods for publishing events. We break these out into separate
    // methods so we can enforce type checking for the event interfaces

    private publishRequestCreatedEvent(data: IRequestCreatedEvent): void {
        tracing.publish(EVENT_REQUEST_CREATED, data);
    }

    private publishRequestDataSentEvent(data: IRequestDataSentEvent): void {
        tracing.publish(EVENT_REQUEST_DATA_SENT, data);
    }

    private publishRequestEndEvent(data: IRequestEndEvent): void {
        tracing.publish(EVENT_REQUEST_END, data);
    }

    private publishRequestErrorEvent(data: IRequestErrorEvent): void {
        tracing.publish(EVENT_REQUEST_ERROR, data);
    }

    private publishResponseReceivedEvent(data: IResponseReceivedEvent): void {
        tracing.publish(EVENT_RESPONSE_RECEIVED, data);
    }

    private publishResponseDataReceivedEvent(data: IResponseDataReceivedEvent): void {
        tracing.publish(EVENT_RESPONSE_DATA_RECEIVED, data);
    }

    private publishResponseEndEvent(data: IResponseEndEvent): void {
        tracing.publish(EVENT_RESPONSE_END, data);
    }

    private publishResponseErrorEvent(data: IResponseErrorEvent): void {
        tracing.publish(EVENT_RESPONSE_ERROR, data);
    }

    public init(httpModule) {
        if (this.proxiedModules.indexOf(httpModule) !== -1) {
            throw new Error('Cannot proxy a module that has already been proxied');
        }
        this.proxiedModules.push(httpModule);

        const oldRequest = httpModule.request;
        const self = this;
        httpModule.request = function request(options, ...requestArgs) {
            const req: ClientRequest = oldRequest.call(this, options, ...requestArgs);
            const id = generateUUID();

            if (tracing.isEventEnabled(EVENT_REQUEST_CREATED)) {
                self.publishRequestCreatedEvent({ id, req, options });
            }

            req.on('response', (res: IncomingMessage) => {
                if (tracing.isEventEnabled(EVENT_RESPONSE_RECEIVED)) {
                    self.publishResponseReceivedEvent({ id, req, res });
                }

                res.on('data', (chunk) => {
                    if (tracing.isEventEnabled(EVENT_RESPONSE_DATA_RECEIVED)) {
                        self.publishResponseDataReceivedEvent({ id, req, res, chunk });
                    }
                });

                res.on('end', () => {
                    if (tracing.isEventEnabled(EVENT_RESPONSE_END)) {
                        self.publishResponseEndEvent({ id, req, res });
                    }
                });

                res.on('error', (error) => {
                    if (tracing.isEventEnabled(EVENT_RESPONSE_ERROR)) {
                        self.publishResponseErrorEvent({ id, req, res, error });
                    }
                });
            });

            req.on('error', (error) => {
                if (tracing.isEventEnabled(EVENT_REQUEST_ERROR)) {
                    self.publishRequestErrorEvent({ id, req, error });
                }
            });

            // Note: it's possible to write data using the `end` method as well,
            // but that method calls `write` under the hood, and patching both
            // leads to a doubly patched write method, which duplicates the body
            const oldWrite = req.write;
            req.write = function(chunk, ...writeArgs) {
                const result = oldWrite.call(this, chunk, ...writeArgs);
                if ((typeof chunk === 'string' || Buffer.isBuffer(chunk)) &&
                    tracing.isEventEnabled(EVENT_REQUEST_DATA_SENT)
                ) {
                    self.publishRequestDataSentEvent({ id, req, chunk });
                }
                return result;
            };

            const oldEnd = req.end;
            req.end = function end(...endArgs) {
                const result = oldEnd.apply(this, endArgs);
                if (tracing.isEventEnabled(EVENT_REQUEST_END)) {
                    self.publishRequestEndEvent({ id, req });
                }
                return result;
            };

            return req;
        };
    }
}
