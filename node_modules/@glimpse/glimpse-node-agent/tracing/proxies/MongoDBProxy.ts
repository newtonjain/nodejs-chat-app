'use strict';

import Tracing from '../Tracing';
import { ProxyBase } from './ProxyBase';
import moment = require('moment');
import fs = require('fs');
import path = require('path');
import semver = require('semver');

/* tslint:disable:no-any */

/**
 * Interface that represents key logic for a proxy 
 */
interface IProxyHelper {
    (methodName: string, originalThis: any, originalArgs: Object): any;
};

export class MongoDBProxy extends ProxyBase {
    private realCollectionMethods: any = {};
    private realCursorMethods: any = {};

    /**
     * event names for mongodb
     */
    public static EVENT_MONGODB_COLLECTION_INSERT = 'invoke|pre|module:/mongodb.collection#insert';
    public static EVENT_MONGODB_COLLECTION_INSERT_METHODS = 'invoke|post|module:/mongodb.collection#insertMethods';
    public static EVENT_MONGODB_COLLECTION_DELETE_METHODS = 'invoke|post|module:/mongodb.collection#deleteMethods';
    public static EVENT_MONGODB_READ_METHODS = 'invoke|post|module:/mongodb#readMethods';
    public static EVENT_MONGODB_COLLECTION_UPDATE_METHODS = 'invoke|post|module:/mongodb.collection#updateMethods';
    public static EVENT_MONGODB_COLLECTION_COUNT = 'invoke|post|module:/mongodb.collection#count';
    public static EVENT_MONGODB_START_READ = 'notify|Module:/mongodb#startRead';

    public getModuleNames() {
      return ['mongodb'];
    };

    public get forceLoadModule(): boolean {
        return false;
    }

    public init(mongodbModule, resolvedPath) {

        if (this.isVersionSupported(resolvedPath)) {
            const self = this;

            /**
             * override of mongodb Collection.prototype.insert
             */
            function insertProxy() {
                const args = MongoDBProxy.swizzleArgs(arguments);
                if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT)) {
                    const data = {
                        originalArgs: args
                    };
                    Tracing.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT, data);
                }
                return self.realCollectionMethods.insert.apply(this, args);
            }

            // Collection overrides
            this.addProxyForCollectionMethod('insert', insertProxy, mongodbModule);
            this.setupCollectionProxy(['deleteMany', 'deleteOne', 'findOneAndDelete', 'remove'], this.deleteProxy, mongodbModule);
            this.setupCollectionProxy(['insertMany', 'insertOne'], this.insertMethodsProxy, mongodbModule);
            this.setupCollectionProxy(['updateOne', 'updateMany', 'replaceOne', 'findOneAndUpdate'], this.updateProxy, mongodbModule);
            this.setupCollectionProxy(['count'], this.collectionReadProxy, mongodbModule);

            // Cursor overrides
            this.setupCursorProxy(['toArray', 'next', 'nextObject'], this.cursorStartReadProxyCallbackOrPromise, mongodbModule);
            this.setupCursorProxy(['forEach', 'each'], this.cursorStartReadProxyCallbackNoPromise, mongodbModule);
        }

        return mongodbModule;
    };

    private isVersionSupported(resolvedPath): boolean {
        if (resolvedPath.endsWith('MockMongoDB.js')) {
            // MockMongoDB is used for testing purposes, so always return true for that 
            return true;
        }

        const dir = path.dirname(resolvedPath);
        const pkgJSON = path.join(dir, 'package.json');
        if (fs.existsSync(pkgJSON)) {
            const contents = fs.readFileSync(pkgJSON, 'utf8');
            const parsed = JSON.parse(contents);
            if (parsed.version) {
                return semver.satisfies(parsed.version, '2.1.x');
            }
        }
        return false;
    }

    /**
     * Add a proxy for a mongoDB collection method
     */
    private setupCollectionProxy(targets: string[], proxyHelper: IProxyHelper, mongoDBModule) {
        const self = this;
        for (let i = 0; i < targets.length; i++) {
            ((key) => {
                function proxy() {
                    return proxyHelper.call(self, key, this, arguments);
                }
                this.addProxyForCollectionMethod(key, proxy, mongoDBModule);
            })(targets[i]);
        }
    }

    /**
     * Add a proxy for a mongoDB collection method
     */
    private setupCursorProxy(targets: string[], proxyHelper: IProxyHelper, mongoDBModule) {
        const self = this;
        for (let i = 0; i < targets.length; i++) {
            ((key) => {
                function proxy() {
                    return proxyHelper.call(self, key, this, arguments);
                }
                this.addProxyForCursorMethod(key, proxy, mongoDBModule);
            })(targets[i]);
        }
    }

    /**
     *  helper method to hookup up a proxy method on the mongoDB collection class
     */
    private addProxyForCollectionMethod(key, proxy, mongodb) {
        this.realCollectionMethods[key] = mongodb.Collection.prototype[key];
        mongodb.Collection.prototype[key] = proxy;
    };

    /**
     * helper method to hookup up a proxy method on the mongoDB cursor class  
     */
    private addProxyForCursorMethod(key, proxy, mongodb) {
        this.realCursorMethods[key] = mongodb.Cursor.prototype[key];
        mongodb.Cursor.prototype[key] = proxy;
    }

    /**
     * helper method to proxy various cursor read statements that support a callback or a promise
     */
    private cursorStartReadProxyCallbackOrPromise(methodName: string, originalThis: any, originalArgs: Object) {
        const startTime = moment();
        const hrtime = process.hrtime();

        function afterSuccess(result) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_READ_METHODS)) {
                const data = {
                    originalThis,
                    methodName,
                    startTime,
                    hrtime,
                    err: undefined
                };

                Tracing.publish(MongoDBProxy.EVENT_MONGODB_READ_METHODS, data);
            }
        };

        function afterFailure(err) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_READ_METHODS)) {
                const data = {
                    originalThis,
                    methodName,
                    startTime,
                    hrtime,
                    err
                };

                Tracing.publish(MongoDBProxy.EVENT_MONGODB_READ_METHODS, data);
            }
        };

        return this.callbackOrPromise(originalThis, originalArgs, 0, 1, this.realCursorMethods[methodName], afterSuccess, afterFailure);
    }

    /**
     * helper method to proxy cursor read statements that support only callbacks
     */
    private cursorStartReadProxyCallbackNoPromise(methodName: string, originalThis: any, originalArgs: Object) {
        if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_START_READ)) {
            const data = {
                originalThis,
                methodName
            };
            Tracing.publish(MongoDBProxy.EVENT_MONGODB_START_READ, data);
        }

        // assume args[0] is the callback we need to wrap
        if (typeof (originalArgs[0]) === 'function') {
            const callback = originalArgs[0];
            function callbackWrapper() {
                if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_READ_METHODS)) {
                    const data = {
                        originalThis,
                        methodName,
                        err: undefined
                    };

                    Tracing.publish(MongoDBProxy.EVENT_MONGODB_READ_METHODS, data);
                }
                callback.apply(this, arguments);
            }
            originalArgs[0] = callbackWrapper;
        }
        return this.realCursorMethods[methodName].apply(originalThis, originalArgs);
    }

    /**
     * Proxy for collection read count 
     */
    private collectionReadProxy(methodName: string, originalThis: any, originalArgs: Object) {
        const startTime = moment();
        const hrtime = process.hrtime();

        function afterSuccess(result) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT)) {
                const data = {
                    originalThis,
                    originalArgs,
                    methodName,
                    startTime,
                    hrtime,
                    err: undefined
                };

                Tracing.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT, data);
            }
        };

        function afterFailure(err) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT)) {
                const data = {
                    originalThis,
                    originalArgs,
                    methodName,
                    startTime,
                    hrtime,
                    err
                };

                Tracing.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT, data);
            }
        };

        return this.callbackOrPromise(originalThis, originalArgs, 0, 3, this.realCollectionMethods[methodName], afterSuccess, afterFailure);
    };

    /**
     *  helper method to proxy various insert methods
     */
    private insertMethodsProxy(methodName: string, originalThis: any, originalArgs: Object) {
        const startTime = moment();
        const hrtime = process.hrtime();

        function afterSuccess(result) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS)) {
                const data = {
                    originalThis,
                    originalArgs,
                    methodName,
                    startTime,
                    hrtime,
                    result,
                    err: undefined
                };

                Tracing.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS, data);
            }

        };

        function afterFailure(err) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS)) {
                const data = {
                    originalThis,
                    originalArgs,
                    methodName,
                    startTime,
                    hrtime,
                    result: undefined,
                    err
                };

                Tracing.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS, data);
            }
        };

        return this.callbackOrPromise(originalThis, originalArgs, 1, 2, this.realCollectionMethods[methodName], afterSuccess, afterFailure);
    };

    /**
     * Proxy for update methods including 'updateOne', 'updateMany', 'replaceOne', 'findOneAndUpdate'
     */
    private updateProxy(methodName: string, originalThis: any, originalArgs: Object) {
        const startTime = moment();
        const hrtime = process.hrtime();

        function afterSuccess(result) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS)) {
                const data = {
                    originalThis,
                    originalArgs,
                    methodName,
                    startTime,
                    hrtime,
                    result,
                    err: undefined
                };

                Tracing.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS, data);
            }
        };

        function afterFailure(err) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS)) {
                const data = {
                    originalThis,
                    originalArgs,
                    methodName,
                    startTime,
                    hrtime,
                    result: undefined,
                    err
                };

                Tracing.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS, data);
            }
        };

        return this.callbackOrPromise(originalThis, originalArgs, 2, 2, this.realCollectionMethods[methodName], afterSuccess, afterFailure);
    };

    /**
     *  helper method to proxy deleteOne, deleteMany or findOneAndDelete
     */
    private deleteProxy(methodName: string, originalThis: any, originalArgs: Object) {
        const startTime = moment();
        const hrtime = process.hrtime();

        function afterDeleteSuccess(result) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS)) {
                const data = {
                    originalThis,
                    originalArgs,
                    methodName,
                    startTime,
                    hrtime,
                    result,
                    err: undefined
                };

                Tracing.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS, data);
            }
        };

        function afterDeleteFailure(err) {
            if (Tracing.isEventEnabled(MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS)) {
                const data = {
                    originalThis,
                    originalArgs,
                    methodName,
                    startTime,
                    hrtime,
                    result: undefined,
                    err
                };
                Tracing.publish(MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS, data);
            }
        };

        return this.callbackOrPromise(originalThis, originalArgs, 1, 2, this.realCollectionMethods[methodName], afterDeleteSuccess, afterDeleteFailure);
    };

    /**
     * helper method that will execute a callback if present, or return a promise.
     *
     * @callbackStartIndex - the string  index into originalArgs of where a callback may be.
     * @callbackProbeLength - the number of slots in originalArgs to probe for a paramater of type function.  This will be the callback.
     * @realMethod - is the actual method that we're proxying.
     * @onSuccess - the callback to raise when @realMethod is successful.
     * @onFailure - the callback to raise when @realMethod fails.
     */
    private callbackOrPromise(
        originalThis,
        originalArgs,
        callbackStartIndex,
        callbackProbeLength,
        realMethod,
        onSuccess,
        onFailure) {
        let originalCallback = undefined;
        let callbackIndex = -1;
        for (let i = callbackStartIndex; i < callbackStartIndex + callbackProbeLength; i++) {
            if (typeof originalArgs[i] === 'function') {
                callbackIndex = i;
                originalCallback = originalArgs[i];
                break;
            }
        }

        if (originalCallback) {
            function callbackWrapper(err, result) {
                if (err) {
                    onFailure(err);
                }
                else {
                    onSuccess(result);
                }
                originalCallback.apply(this, arguments);
            };

            // replace callback in arguments array
            originalArgs[callbackIndex] = callbackWrapper;

            return realMethod.apply(originalThis, originalArgs);
        }
        else {
            // no callback specified, so we return a promise.
            // this.s.promiseLibrary is a promise constructor.  this.s is Collection's internal state
            function promiseFunction(resolve, reject) {
                function proxySuccess(r) {
                    onSuccess.apply(this, arguments);
                    resolve(r);
                };
                function proxyFailed(err) {
                    onFailure.apply(this, arguments);
                    reject(err);
                };

                realMethod.apply(originalThis, originalArgs)
                    .then(proxySuccess, proxyFailed);
            }

            return new originalThis.s.promiseLibrary(promiseFunction);
        }
    };

    /**
     * Normalizes position of optional options and callback arguments on the given array.
     */
    private static swizzleArgs(argsArray) {
        if (!Array.isArray(argsArray)) {
            argsArray = Array.prototype.slice.call(argsArray, 0);
        }

        if (typeof argsArray[1] === 'function') {
            argsArray.push(argsArray[1]);
            argsArray[1] = {};
        }
        else if (!argsArray[1]) {
            argsArray[1] = {};
        }
        return argsArray;
    }
}
