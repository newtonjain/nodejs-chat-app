'use strict';

import { IAgent } from '../IAgent';
import { IContextManager } from '../messaging/IContextManager';
import { ProxyBase } from './ProxyBase';
import util = require('util');

/* tslint:disable:no-any */

/**
 * Interface that represents key logic for a proxy 
 */
interface ProxyMethod {
    (originalThis: Object, originalArgs: any, realMethod: any): any;
};

enum LogLevel { Debug, Verbose, Information, Warning, Error, Critical };

/**
 * Represents a region in a string that was replaced by a format statement.  
 */
export class ReplacementRegion {
    public start: number;
    public end: number;
}

/**
 * Information resulting from a format statement  
 */
export class FormatInfo {
    public message: string;
    public replacementRegions: ReplacementRegion[];
}

/**
 * The Proxy class for Console logging
 */
export class ConsoleProxy extends ProxyBase {

    private agent: IAgent;
    private contextManager: IContextManager;
    private _realConsoleMethods: any = {};
    private _realConsolePrototypeMethods: any = {};

    /**
     * Init the proxy.
     */
    public init(agent: IAgent, consoleModule: any): any {

        this.agent = agent;
        this.contextManager = agent.providers.contextManager;

        this.addProxy('assert', 'assert', this.assert, consoleModule);
        this.addProxy('debug', 'debug', this.debug, consoleModule);  // debug() is not supported on Node, but leave here for client platforms where it may be supported.fs
        this.addProxy('error', 'warn', this.error, consoleModule);  // route "error" calls through to warn
        this.addProxy('info', 'log', this.info, consoleModule);  // route "info" calls through to log
        this.addProxy('log', 'log', this.log, consoleModule);
        this.addProxy('warn', 'warn', this.warn, consoleModule);

        return consoleModule;
    };

    public get forceLoadModule(): boolean {
        // we need to load the Console module asap, as users can call the console.* methods without calling require('console').  
        return true;
    }

    public get moduleName() { return 'console'; };

    /**
     * helper method that will send the appropriate glimpse message and invoke the underlying console method
     */
    private proxyHelper(originalThis, originalArgs, realMethod, logLevel: LogLevel) {
        const formatInfo = ConsoleProxy.getFormatInfo(originalArgs, 0);
        this.sendLogWriteMessage(formatInfo.message, logLevel, undefined, formatInfo.replacementRegions);
        return realMethod.apply(originalThis, originalArgs);
    }

    /**
     * logic to send messages for Console.assert()
     */
    private assert(originalThis, originalArgs, realMethod) {
        if (!originalArgs || !originalArgs[0]) {
            const formatInfo = ConsoleProxy.getFormatInfo(originalArgs, 1);
            this.sendLogWriteMessage(formatInfo.message, LogLevel.Error, undefined, formatInfo.replacementRegions);
        }
        return realMethod.apply(originalThis, originalArgs);
    };

    /**
     * This is a no-op for now as Node doesn't support debug, but browsers do, so we'll leave this here for when this
     * proxy is hooked up on browser clients.
     */
    private debug(originalThis, originalArgs, realMethod) {
        return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Error);
    };

    /**
     * Logic to send glimpse messages for Console.error()
     */
    private error(originalThis, originalArgs, realMethod) {
        return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Error);
    };

    /**
     * Logic to send glimpse messages for Console.info()
     */
    private info(originalThis, originalArgs, realMethod) {
        return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Information);
    }

    /**
     * Logic to send glimpse messages for Console.log()
     */
    private log(originalThis, originalArgs, realMethod) {
        return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Verbose);
    }

    /**
     * Logic to send glimpse messages for Console.warn()
     */
    private warn(originalThis, originalArgs, realMethod) {
        return this.proxyHelper(originalThis, originalArgs, realMethod, LogLevel.Warning);
    }

    /**
     * Retrieve the formatInfo from the arguments passed to a console log statement
     */
    public static getFormatInfo(originalArgs, messageIndex): FormatInfo {
        const formatInfo = new FormatInfo();
        const formatArgs = Array.prototype.slice.call(originalArgs, messageIndex);
        formatInfo.message = util.format.apply(util, formatArgs);
        formatInfo.replacementRegions = ConsoleProxy.getReplacementRegions(formatArgs);
        return formatInfo;
    }

    /**
     * Given a format string and a set of params, return the array of regions in the formtted string that 
     * were replaced by the format command. 
     * 
     * Returns an array of ReplacementRegion objects, where start is inclusive and end is exclusive.
     */
    private static getReplacementRegions(formatArgs: any[]): ReplacementRegion[] {
        const format = formatArgs[0];
        const regions: ReplacementRegion[] = [];
        if (typeof format === 'string') {
            const params = formatArgs.slice(1);
            if (params && params.length > 0) {
                let currentParam = 0;
                let nextStart = 0;
                let i = 0;
                while (i < format.length && currentParam < params.length) {
                    if (format[i] === '%' && i < format.length - 1) {
                        const nextChar = format[i + 1];
                        if (nextChar === '%') {
                            // escaped percent, advance i by 2 and nextStart by 1
                            i += 2;
                            nextStart += 1;
                        }
                        else if (nextChar === 's' || nextChar === 'd' || nextChar === 'j') {
                            const region: ReplacementRegion = new ReplacementRegion();
                            const currentFormat = '%' + nextChar;
                            const currentFormattedLength = util.format(currentFormat, params[currentParam]).length;
                            region.start = nextStart;
                            nextStart += currentFormattedLength;
                            region.end = nextStart;
                            regions.push(region);
                            currentParam++;
                            i += 2;
                        }
                        else {
                            // unescaped %, just advance
                            i++;
                            nextStart++;
                        }
                    }
                    else {
                        i++;
                        nextStart++;
                    }
                }
            }
        }
        return regions;
    }

    /**
     * Send the 'log-write' glimpse message
     */
    private sendLogWriteMessage(
        message: string,
        level: LogLevel,
        category: string,
        replacedRegions: ReplacementRegion[]
    ) {
        const context = this.contextManager.currentContext();
        if (context) {
            const startTime = this.agent.providers.dateTime.now;
            // don't send an empty array
            replacedRegions = (replacedRegions && replacedRegions.length > 0) ? replacedRegions : undefined;
            this.agent.broker.sendMessage(
                {
                    message: message,
                    level: LogLevel[level],
                    source: 'Server',
                    category: category,
                    startTime: startTime.format(),
                    replacedRegions: replacedRegions
                },
                ['log-write']);
        }
    };

    /**
     *  helper method to hookup up a proxy method on the Console object.  This helper
     *  accounts for the fact that there could potentially be two different sets of 
     *  log methods, the 'console.*' methods, and then the Console.prototype.* methods. 
     */
    private addProxy(methodToProxy: string, methodToCall: string, proxyFunction: ProxyMethod, consoleModule) {
        const self = this;

        if (this._realConsoleMethods[methodToProxy] || this._realConsolePrototypeMethods[methodToProxy]) {
            throw new Error(util.format('Attempted to add proxy twice for method %s', methodToProxy));
        }

        if (consoleModule[methodToProxy]) {
            this._realConsoleMethods[methodToProxy] = consoleModule[methodToProxy];
            function p1() {
                proxyFunction.call(self, this, arguments, self._realConsoleMethods[methodToCall]);
            };
            consoleModule[methodToProxy] = p1;
        }

        if (consoleModule.Console.prototype[methodToProxy]) {
            this._realConsolePrototypeMethods[methodToProxy] = consoleModule.Console.prototype[methodToProxy];
            function p2() {
                proxyFunction.call(self, this, arguments, self._realConsolePrototypeMethods[methodToCall]);
            };
            consoleModule.Console.prototype[methodToProxy] = p2;
        }
    };
}
