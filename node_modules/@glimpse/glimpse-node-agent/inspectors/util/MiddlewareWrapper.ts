'use strict';

import { IAgentBroker } from '../../messaging/IAgentBroker';
import { IContext, IContextManager } from '../../messaging/IContextManager';
import { IDateTime } from '../../configuration/IDateTime';
import { ResponseListener } from './ResponseListener';
import { GuidHelper } from '../../util/GuidHelper';
import { HttpHelper } from './HttpHelper';

import * as _ from 'lodash';
import * as http from 'http';

interface IEndFunction {
    ();
}

interface IMiddlewareContext {
    stack: IEndFunction[];
}

interface IExtendedContext extends IContext {
    middleware: IMiddlewareContext;
}

export interface IMiddlewareStartPayload {
    correlationId: string;
    name: string;
    displayName?: string;
    packageName?: string;
    paths?: string[];
    method?: string;
    params?: { [key: string]: string };
    startTime: string;
}

export interface IMiddlewareHeaderOperation {
    op: string;
    name: string;
    value?: string[];
}

export interface IMiddlewareEndPayload {
    correlationId: string;
    name: string;
    displayName?: string;
    packageName?: string;
    paths?: string[];
    method?: string;
    params?: { [key: string]: string };
    endTime: string;
    duration: number;
    headers?: IMiddlewareHeaderOperation[];
    result: string;
}

export interface IMiddlewareNextCallback {
    (result?: string | Error);
}

export interface IMiddlewareMetadata {
    ignore?: boolean;
    name?: string;
    displayName?: string;
    packageName?: string;
}

export interface IMiddlewareFunction {
    (req?: http.IncomingMessage, res?: http.ServerResponse, next?: IMiddlewareNextCallback);

    name?: string;
    glimpse?: IMiddlewareMetadata;
}

export interface IMiddlewareErrorFunction {
    /* tslint:disable no-any */
    (err: any, req?: http.IncomingMessage, res?: http.ServerResponse, next?: IMiddlewareNextCallback);
    /* tslint:enable no-any */

    name?: string;
    glimpse?: IMiddlewareMetadata;
}

export interface IMiddlewareFunctionContext {
    originalName?: string;
}

export interface IWrappedMiddlewareFunction extends IMiddlewareFunction {
    glimpse?: IMiddlewareFunctionContext;
}

export interface IWrappedMiddlewareErrorFunction extends IMiddlewareErrorFunction {
    glimpse?: IMiddlewareFunctionContext;
}

export interface IExpressRequest extends http.IncomingMessage {
    params?: { [key: string]: string };
}

export class MiddlewareWrapper {
    private static wrapCommonMiddleware(
        broker: IAgentBroker,
        contextManager: IContextManager,
        dateTime: IDateTime,
        paths: string[],
        method: string,
        originalMiddlewareName: string,
        middlewareMetadata: IMiddlewareMetadata,
        req: IExpressRequest,
        res: http.ServerResponse,
        next: IMiddlewareNextCallback,
        originalMiddleware: IMiddlewareFunction) {

        const context: IExtendedContext = <IExtendedContext>HttpHelper.getContext(res);

        if (!context) {
            return originalMiddleware(req, res, next);
        }

        contextManager.checkContextID('MiddlewareWrapper::MiddlewareWrapper', context ? context.id : undefined);

        const correlationId = GuidHelper.newGuid();
        const startTime = dateTime.now;

        let name = originalMiddlewareName || '<anonymous>';
        let displayName = undefined;
        let packageName = undefined;

        if (middlewareMetadata) {
            name = middlewareMetadata.name || name;
            displayName = middlewareMetadata.displayName;
            packageName = middlewareMetadata.packageName;
        }

        const startPayload: IMiddlewareStartPayload = {
            correlationId: correlationId,
            name: name,
            startTime: startTime.format()
        };

        if (displayName) {
            startPayload.displayName = displayName;
        }

        if (packageName) {
            startPayload.packageName = packageName;
        }

        if (paths && paths.length > 0) {
            startPayload.paths = paths;
        }

        if (method) {
            startPayload.method = method;
        }

        if (req.params && !_.isEmpty(req.params)) {
            startPayload.params = req.params;
        }

        broker.sendMessage(
            startPayload,
            ['middleware-express', 'middleware-start'],
            /* indices */ undefined,
            context);

        const headers: { [key: string]: string[] } = {};

        function publishMiddlewareEnd(result) {
            const endTime = dateTime.now;
            const duration = endTime.diff(startTime);

            const endPayload: IMiddlewareEndPayload = {
                correlationId: correlationId,
                name: name,
                endTime: endTime.format(),
                duration: duration,
                result: result
            };

            if (displayName) {
                endPayload.displayName = displayName;
            }

            if (packageName) {
                endPayload.packageName = packageName;
            }

            if (!_.isEmpty(headers)) {
                endPayload.headers = _.map(headers, (value, key) => {
                    return {
                        op: 'set',
                        name: key,
                        values: value
                    };
                });
            }

            if (paths && paths.length > 0) {
                endPayload.paths = paths;
            }

            if (method) {
                endPayload.method = method;
            }

            if (req.params && !_.isEmpty(req.params)) {
                endPayload.params = req.params;
            }

            broker.sendMessage(
                endPayload,
                [ 'middleware-express', 'middleware-end' ],
                /* indices */ undefined,
                context);
        };

        function onPublishMiddlewareEnd() {
            publishMiddlewareEnd(/* result */ 'end');
        };

        if (!context.middleware) {
            context.middleware = {
                stack: []
            };
        }

        context.middleware.stack.push(onPublishMiddlewareEnd);

        function onResponseFinish() {
            while (context.middleware.stack.length > 0) {
                const endFunction = context.middleware.stack.pop();

                endFunction();
            }
        };

        res.on('finish', onResponseFinish);

        function onHeaders(newHeaders) {
            _.assign(headers, newHeaders);
        }

        const responseListener = ResponseListener.attachListener(res);

        responseListener.on(ResponseListener.headersEvent, onHeaders);

        let publishedEnd = false;

        const newNext = contextManager.wrapInCurrentContext(function newNextInternal() {

            contextManager.checkContextID('MiddlewareWrapper::newNext', context.id);

            res.removeListener('finish', onResponseFinish);

            responseListener.removeListener(ResponseListener.headersEvent, onHeaders);

            context.middleware.stack.pop();

            let result = 'next';

            if (arguments && arguments.length > 0 && arguments[0] !== 'route') {
                result = 'error';
            }

            publishMiddlewareEnd(/* result */ result);

            publishedEnd = true;

            return next.apply(this, arguments);
        });

        try {
            originalMiddleware(req, res, newNext);
        }
        catch (err) {

            // NOTE: If the original middleware calling next() throws an exception it will be caught here,
            //       but we've already published the middleware-end message so there's no need to do it here.

            if (!publishedEnd) {
                res.removeListener('finish', onResponseFinish);

                responseListener.removeListener(ResponseListener.headersEvent, onHeaders);

                context.middleware.stack.pop();

                publishMiddlewareEnd(/* result */ 'error');

                publishedEnd = true;
            }

            throw err;
        }
    }

    private static wrapErrorMiddleware(
        broker: IAgentBroker,
        contextManager: IContextManager,
        dateTime: IDateTime,
        paths: string[],
        method: string,
        originalMiddleware: IMiddlewareErrorFunction): IWrappedMiddlewareErrorFunction {
        const wrappedMiddleware = <IWrappedMiddlewareErrorFunction>function wrappedMiddleware(err, req, res, next) {
            MiddlewareWrapper.wrapCommonMiddleware(
                broker,
                contextManager,
                dateTime,
                paths,
                method,
                originalMiddleware.name,
                originalMiddleware.glimpse,
                req,
                res,
                next,
                (q, r, n) => {
                    originalMiddleware(err, q, r, n);
                });
        };

        wrappedMiddleware.glimpse = {
            originalName: originalMiddleware.name
        };

        return wrappedMiddleware;
    }

    private static wrapMiddleware(
        broker: IAgentBroker,
        contextManager: IContextManager,
        dateTime: IDateTime,
        paths: string[],
        method: string,
        originalMiddleware: IMiddlewareFunction): IWrappedMiddlewareFunction {
        const wrappedMiddleware = <IWrappedMiddlewareFunction>function wrappedMiddleware(req, res, next) {
            MiddlewareWrapper.wrapCommonMiddleware(
                broker,
                contextManager,
                dateTime,
                paths,
                method,
                originalMiddleware.name,
                originalMiddleware.glimpse,
                req,
                res,
                next,
                (q, r, n) => {
                    originalMiddleware(q, r, n);
                });
        };

        wrappedMiddleware.glimpse = {
            originalName: originalMiddleware.name
        };

        return wrappedMiddleware;
    }

    public static wrap(
        broker: IAgentBroker,
        contextManager: IContextManager,
        dateTime: IDateTime,
        paths: string[],
        method: string,
        originalMiddleware: IMiddlewareFunction | IMiddlewareErrorFunction): IWrappedMiddlewareFunction | IWrappedMiddlewareErrorFunction {
        if (originalMiddleware && typeof originalMiddleware === 'function') {
            if (originalMiddleware.length === 2 || originalMiddleware.length === 3) {
                return MiddlewareWrapper.wrapMiddleware(broker, contextManager, dateTime, paths, method, <IMiddlewareFunction>originalMiddleware);
            }

            if (originalMiddleware.length === 4) {
                return MiddlewareWrapper.wrapErrorMiddleware(broker, contextManager, dateTime, paths, method, <IMiddlewareErrorFunction>originalMiddleware);
            }
        }

        return originalMiddleware;
    }

    public static attachMetadata(middleware: IMiddlewareFunction, name: string, displayName: string, packageName: string): void {
        if (middleware) {
            const metadata: IMiddlewareMetadata = middleware.glimpse || {};

            if (!middleware.glimpse) {
                middleware.glimpse = metadata;
            }

            if (!metadata.name) {
                metadata.name = name;
            }

            if (!metadata.displayName) {
                metadata.displayName = displayName;
            }

            if (!metadata.packageName) {
                metadata.packageName = packageName;
            }
        }
    }
}
