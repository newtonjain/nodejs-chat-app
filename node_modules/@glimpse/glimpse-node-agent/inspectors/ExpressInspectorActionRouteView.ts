'use strict';

import { GuidHelper} from './../util/GuidHelper';
import { IAgentBroker } from '../messaging/IAgentBroker';
import { IContext, IContextManager } from '../messaging/IContextManager';
import { IDateTime } from '../configuration/IDateTime';
import { IErrorReportingService } from '../errors/IErrorReportingService';
import { IScriptManager } from '../messaging/IScriptManager';
import { IWrappedMiddlewareFunction } from './util/MiddlewareWrapper';
import { ExpressProxy } from './../tracing/proxies/ExpressProxy';
import { HttpHelper } from './util/HttpHelper';
import Tracing from './../tracing/Tracing';

import * as path from 'path';

interface IExtendedContext extends IContext {
    action?;
}

export class ExpressInspectorActionRouteView {

    private broker: IAgentBroker;
    private contextManager: IContextManager;
    private dateTime: IDateTime;
    private errorReportingService: IErrorReportingService;
    private scriptManager: IScriptManager;

    public init(broker: IAgentBroker, contextManager: IContextManager, dateTime: IDateTime, errorReportingService: IErrorReportingService, scriptManager: IScriptManager) {
        this.broker = broker;
        this.contextManager = contextManager;
        this.dateTime = dateTime;
        this.errorReportingService = errorReportingService;
        this.scriptManager = scriptManager;

        Tracing.onAlways(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_ROUTE_DISPATCH, (event) => {
            this.onRouteDispatch(event.data.originalThis);
        });

        Tracing.onAlways(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_RESPONSE_RENDER, (event) => {
            // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/320 - test missing
            this.onResponseRender(event.data.originalThis);
        });

        Tracing.onAlways(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_RESPONSE_SEND, (event) => {
            // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/320 - test missing
            this.onResponseSend(event.data.originalThis, event.data.originalArgs);
        });

        Tracing.onAlways(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_RESPONSE_END, (event) => {
            // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/320 - test missing
            this.onResponseEnd(event.data.originalThis);
        });

        Tracing.onAlways(ExpressProxy.EVENT_NOTIFY_EXPRESS_RENDER_COMPLETE, (event) => {
            if (event.data.err) {
                this.onRenderCompleteError(event.data.err);
            }
            else {
                // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/320 - test missing
                this.onRenderComplete();
            }
        });

        Tracing.onAlways(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_VIEW_RENDER, (event) => {
            this.onViewRender(event.data.originalThis);
        });
    }

    private onRouteDispatch(route) {
        // TODO: figure out what correct data to display here for a "route" and an "action"

        const middlewareFunction: IWrappedMiddlewareFunction = route.stack[0].handle;
        let functionName;

        if (middlewareFunction.glimpse) {
            functionName = middlewareFunction.glimpse.originalName || '<anonymous>';
        }
        else {
            functionName = middlewareFunction.name || '<anonymous>';
        }

        const actionId = GuidHelper.newGuid();
        const actionName = functionName;
        const actionDisplayName = functionName;
        const actionControllerName = functionName;
        const actionStartTime = new Date();

        this.broker.sendMessage(
            {
                actionId: actionId,
                actionName: actionName,
                actionDisplayName: actionDisplayName,
                actionControllerName: actionControllerName,

                // 'begin-action', 'action-route'
                actionStartTime: actionStartTime,
                routeName: functionName,
                routePattern: route.path,
                routeData:
                {
                    controller: actionControllerName,
                    action: actionName
                },

                // 'before-action-invoked', 'action-content'
                actionTargetClass: '',
                actionTargetMethod: '',
                actionInvokedStartTime: actionStartTime,

                /* tslint:disable no-null-keyword */
                binding: null
                /* tslint:enable no-null-keyword */

            },
            ['begin-action', 'action-route', 'before-action-invoked', 'action-content']);

        // Save some action-related context for response rendering...

        const extendedContext: IExtendedContext = this.contextManager.currentContext();
        extendedContext.action = {
            actionId: actionId,
            actionName: actionName,
            actionControllerName: actionControllerName,
            actionStartTime: actionStartTime,
            beforeActionInvokedSent: true,
            afterActionInvokedSent: false
        };
    }

    private onResponseEnd(response) {
        const context: IExtendedContext = HttpHelper.getContext(response);
        this.contextManager.checkContextID('ExpressInspectorActionRouteView::onResponseEnd()', context ? context.id : undefined);
        if (!context) {
            return;
        }

        const actionContext = context.action;
        // ensure that we send after-action-invoked if it hasn't already been sent.
        // TODO:  There's probably a better way to do this.
        if (actionContext && actionContext.beforeActionInvokedSent && !actionContext.afterActionInvokedSent) {
            const startTime = new Date();

            this.broker.sendMessage(
                {
                    actionId: actionContext.actionId,
                    actionName: actionContext.actionName,
                    actionControllerName: actionContext.actionControllerName,

                    // 'after-action-invoked'
                    actionInvokedEndTime: startTime,
                    actionInvokedDuration: startTime.getTime() - actionContext.actionStartTime.getTime(),
                    actionInvokedOffset: actionContext.actionStartTime.getTime() - context.startTime.getTime()
                },
                ['after-action-invoked'],
                undefined,
                context);

            actionContext.afterActionInvokedSent = true;
        }
    }

    private onRenderCompleteError(err) {
        const context: IExtendedContext = this.contextManager.currentContext();
        this.contextManager.checkContextID('ExpressInspectorActionRouteView::onRenderCompleteError()');
        if (!context) {
            return;
        }

        const actionContext = context.action;
        if (!actionContext) {
            return;
        }

        if (err.view) {
            let viewPath = err.view.path;
            if (!viewPath) {
                viewPath = path.join(err.view.root, err.view.name) + err.view.ext;
            }
            const viewFound = err.view.path ? true : false;
            ExpressInspectorActionRouteView.sendActionViewFound(this.broker, this.dateTime, err.view.name, viewPath, viewFound);
        }
    }

    private onRenderComplete() {
        this.contextManager.checkContextID('ExpressInspectorActionRouteView::onRenderComplete()');
        const context: IExtendedContext = this.contextManager.currentContext();
        if (!context) {
            return;
        }

        const actionContext = context.action;
        if (!actionContext) {
            return;
        }

        const startTime = actionContext.responseRenderStartTime;
        const endTime = new Date();

        this.broker.sendMessage(
            {
                actionId: actionContext.actionId,
                actionName: actionContext.actionName,
                actionControllerName: actionContext.actionControllerName,

                // 'after-action-view-invoked'
                viewEndTime: endTime,
                viewDuration: endTime.getTime() - startTime.getTime(),
                viewOffset: startTime.getTime() - context.startTime.getTime(),

                // 'after-action'
                actionEndTime: endTime,
                actionDuration: endTime.getTime() - actionContext.actionStartTime.getTime(),
                actionOffset: actionContext.actionStartTime.getTime() - context.startTime.getTime()
            },
            ['after-action-view-invoked', 'after-action'],
            undefined,
            context);
    }

    private onResponseRender(response) {
        const context: IExtendedContext = HttpHelper.getContext(response);
        this.contextManager.checkContextID('ExpressInspectorActionRouteView::onResponseRender()', context ? context.id : undefined);
        if (!context) {
            return;
        }

        const actionContext = context.action;
        if (!actionContext) {
            return;
        }

        const startTime = new Date();
        actionContext.responseRenderStartTime = startTime;

        this.broker.sendMessage(
            {
                actionId: actionContext.actionId,
                actionName: actionContext.actionName,
                actionControllerName: actionContext.actionControllerName,

                // 'after-action-invoked'
                actionInvokedEndTime: startTime,
                actionInvokedDuration: startTime.getTime() - actionContext.actionStartTime.getTime(),
                actionInvokedOffset: actionContext.actionStartTime.getTime() - context.startTime.getTime(),

                // 'before-action-view-invoked'
                viewStartTime: startTime
            },
            ['after-action-invoked', 'before-action-view-invoked'],
            undefined,
            context);

        actionContext.afterActionInvokedSent = true;
    }

    private onViewRender(view) {
        const viewPath = view.path || path.join(view.root, view.name) + view.ext;
        const foundView = view.path ? true : false;
        ExpressInspectorActionRouteView.sendActionViewFound(this.broker, this.dateTime, view.name, viewPath, foundView);
    }

    private onResponseSend(response, originalArgs) {

        // OK to continue if no context, we'll just have an empty guid for the context ID in the HUD
        const context: IContext = HttpHelper.getContext(response);
        this.contextManager.checkContextID('ExpressInspectorActionRouteView::onResponseSend()', context ? context.id : undefined);

        let position = 0;
        if (originalArgs.length === 2 && typeof originalArgs[0] === 'number' && typeof originalArgs[1] !== 'number') {
            position = 1;
        }
        else if (originalArgs.length === 1 && typeof originalArgs[0] === 'number') {
            position = -1;
        }

        // TODO: this should be an extension point
        if (position >= 0 && typeof originalArgs[position] === 'string' && response.req.baseUrl !== '/glimpse') {
            const contentType = response.get('Content-Type'); // NOTE: Get is case-insensitive.

            if (contentType === undefined || contentType === 'text/html') {
                const scripts = this.scriptManager.getScriptTagsForCurrentRequest(context);
                let body = originalArgs[position];
                body = this.scriptManager.injectScript(body, scripts);
                originalArgs[position] = body;
            }
        }
    }

    public static sendActionViewFound(broker: IAgentBroker, dateTime: IDateTime, viewName: string, viewPath: string, viewFound: boolean) {
        const viewSearchedTime = dateTime.now;
        broker.sendMessage(
            {
                // 'action-view-found'
                viewName: viewName,
                viewPath: viewPath,
                viewDidFind: viewFound,
                viewSearchedTime: viewSearchedTime
            },
            ['action-view-found']);
    }
}
