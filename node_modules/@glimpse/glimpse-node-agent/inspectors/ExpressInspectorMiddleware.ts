'use strict';

import { IAgentBroker } from '../messaging/IAgentBroker';
import { IContextManager } from '../messaging/IContextManager';
import { IDateTime } from '../configuration/IDateTime';
import { MiddlewareWrapper } from './util/MiddlewareWrapper';
import Tracing from './../tracing/Tracing';
import {ExpressProxy} from './../tracing/proxies/ExpressProxy';

export class ExpressInspectorMiddleware {

    private broker: IAgentBroker;
    private contextManager: IContextManager;
    private dateTime: IDateTime;

    public init(broker: IAgentBroker, contextManager: IContextManager, dateTime: IDateTime) {
        this.broker = broker;
        this.contextManager = contextManager;
        this.dateTime = dateTime;

        Tracing.onAlways(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_ROUTE_METHOD, (event) => {
            this.onMiddlewareMethodInvoked(event.data.originalThis.path, event.data.originalArgs, event.data.methodName);
        });

        Tracing.onAlways(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_ROUTER_USE, (event) => {
            this.onUseInvokedBegin(event.data.originalThis, event.data.originalArgs);
        });

        Tracing.onAlways(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_ROUTER, (event) => {
            this.onRouterInvokedEnd(event.data.router);
        });

        Tracing.onAlways(ExpressProxy.EVENT_INVOKE_PRE_EXPRESS_STATIC, (event) => {
            this.onStaticInvokedEnd(event.data.middleware);
        });
    }

    private onMiddlewareMethodInvoked(path, originalArgs, method) {
        if (originalArgs && originalArgs.length === 1 && typeof originalArgs[0] === 'function') {
            originalArgs[0] = MiddlewareWrapper.wrap(this.broker, this.contextManager, this.dateTime, [path], method !== 'all' ? method.toUpperCase() : undefined, originalArgs[0]);
        }
    }

    private onUseInvokedBegin(originalThis, originalArgs) {
        if (originalThis.glimpse && originalThis.glimpse.ignore) {
            return;
        }

        if (originalArgs && originalArgs.length >= 1) {
            let paths = ['/'];

            if (originalArgs.length > 1) {
                const firstArg = originalArgs[0];

                if (Array.isArray(firstArg) && firstArg.length > 0 && typeof firstArg[0] === 'string') {
                    paths = firstArg;
                }
                else if (typeof firstArg === 'string') {
                    paths = [firstArg];
                }
                else if (firstArg instanceof RegExp) {
                    paths = [firstArg.toString()];
                }
            }
            else if (originalArgs.length === 1) {
                const middleware = originalArgs[0];

                if (typeof middleware === 'function') {
                    if (!originalThis.glimpse) {
                        originalThis.glimpse = {
                            firstUse: middleware
                        };
                    }
                    else if (!originalThis.glimpse.firstUse) {
                        originalThis.glimpse.firstUse = middleware;
                    }
                    else if (!originalThis.glimpse.secondUse) {
                        originalThis.glimpse.secondUse = middleware;

                        // NOTE: If the first and second middleware added to a Router are 'query' and 'expressInit',
                        //       respectively, it's relatively certain that it's the built-in Express middleware that
                        //       we can't otherwise patch in order to attach metadata, so we do so here.

                        if (originalThis.glimpse.firstUse.name === 'query' && originalThis.glimpse.secondUse.name === 'expressInit') {
                            MiddlewareWrapper.attachMetadata(originalThis.glimpse.firstUse, 'query', 'Express Query Parser', 'express');
                            MiddlewareWrapper.attachMetadata(originalThis.glimpse.secondUse, 'expressInit', 'Express Initialization', 'express');
                        }
                    }
                }
            }

            this.wrapNestedMiddleware(originalArgs, paths);
        }
    }

    private wrapNestedMiddleware(array, paths: string[]) {
        for (let i = 0; i < array.length; i++) {
            const arg = array[i];

            if (typeof arg === 'function') {
                if (arg.glimpse && arg.glimpse.ignore) {
                    continue;
                }

                array[i] = MiddlewareWrapper.wrap(this.broker, this.contextManager, this.dateTime, paths, /* method */ undefined, arg);
            }
            else if (Array.isArray(arg)) {
                this.wrapNestedMiddleware(arg, paths);
            }
        }
    }

    private onRouterInvokedEnd(router) {
        MiddlewareWrapper.attachMetadata(router, 'router', 'Express Router', 'express');
    }

    private onStaticInvokedEnd(middleware) {
        MiddlewareWrapper.attachMetadata(middleware, 'serveStatic', 'Express Static File Server', 'express');
    }
}
