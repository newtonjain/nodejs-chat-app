'use strict';

import http = require('http');
import { IContext } from '../messaging/IContextManager';
import { IAgent } from '../IAgent';
import { IServerRequestInspector } from './IServerRequestInspector';
import { ProxyBase } from './ProxyBase';
import { RequestHelper, ResponseHelper} from './util/HttpHelper';
import { GuidHelper } from '../util/GuidHelper';
import { HttpHelper } from './util/HttpHelper';

// TODO: Expose to configuration
const MAX_BODY_SIZE = 132000;
const SESSION_COOKIE = '.Glimpse.Session';

class ServerProxy {
    private inspectors: IServerRequestInspector[] = [];
    private proxiedModules = [];
    private agent: IAgent;

    /* tslint:disable:no-any */
    private raiseRequestStartEvent(req: http.IncomingMessage, res: http.ServerResponse): void {
        /* tslint:enable:no-any */
        for (const inspector of this.inspectors) {
            inspector.requestStart(req, res);
        }
    }

    /* tslint:disable:no-any */
    private raiseRequestEndEvent(req: http.IncomingMessage, res: http.ServerResponse, content: Array<any>, size: number): void {
        /* tslint:enable:no-any */
        for (const inspector of this.inspectors) {
            inspector.requestEnd(req, res, content, size);
        }
    }

    /* tslint:disable:no-any */
    private raiseResponseEndEvent(req: http.IncomingMessage, res: http.ServerResponse, content: Array<any>, size: number): void {
        /* tslint:enable:no-any */
        for (const inspector of this.inspectors) {
            inspector.responseEnd(req, res, content, size);
        }
    }

    private setupServerProxy(agent: IAgent, httpModule): void {
        const oldCreateServer = httpModule.createServer;
        const self = this;
        httpModule.createServer = function createServer(options, cb, ...args) {
            function internalCallback(req: http.IncomingMessage, res: http.ServerResponse, ...rest) {
                agent.providers.contextManager.runInNewContext(req, (context: IContext) => {
                    // store context on req/response
                    HttpHelper.setContext(req, context);
                    HttpHelper.setContext(res, context);

                    self.raiseRequestStartEvent(req, res);

                    // It is possible in some circumstances that `res.end()` is
                    // called before the `data` event on the `req` object is
                    // fired. In this case, we check this flag and send the before
                    // event immediately before sending the end event.
                    let requestEndSent = false;

                    // Note: the User Inspector class was rolled into this one
                    // because the begin/end events weren't fine graind enough
                    // to set these headers at the appropriate time. Once this
                    // module is ported to the new proxy paradigm, this can be
                    // split back into a separate inspector
                    // BEGIN code from UserInspector
                    const requestCookies = RequestHelper.parseCookies(req);
                    const userId = requestCookies ? requestCookies[SESSION_COOKIE] : undefined;
                    if (!userId) {
                        ResponseHelper.setCookie(res, SESSION_COOKIE, GuidHelper.newGuid(false));
                    }
                    // END code from UserInspector

                    res.setHeader('X-Glimpse-ContextId', context.id);

                    if (cb) {
                        cb(req, res, ...rest);
                    }

                    // General performance note for this implementation: this has been identified
                    // as a hot path for performance, so there are places where maintainability
                    // and readability are sacrificed for performance. Specifically, there is
                    // repeated code in here that could be abstracted into helper methods, but
                    // would incure the extra stack frame and slow things down

                    // Note on Buffers. We use Buffers to store body requests, and we
                    // create new buffers a few times as well. We use the Buffer consructor
                    // to do this for backwards compatibility reasons, but we should
                    // migrate away some day. There is a security risk with using the
                    // Buffer constructor, which is why it's been deprecated. More info:
                    // https://nodejs.org/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe

                    // Chunks may be read back as either Buffers or strings. For now we store
                    // them as an array of chunks, and let inspectors figure out the best way
                    // to normalize them.
                    let requestBodyChunks = [];
                    let requesBodyLength = 0;

                    req.on('data', (chunk) => {
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'data\')', context.id);
                        const originalChunkLength = chunk.length;
                        if (requesBodyLength < MAX_BODY_SIZE) {
                            if (requesBodyLength + originalChunkLength >= MAX_BODY_SIZE) {
                                chunk = chunk.slice(0, MAX_BODY_SIZE - requesBodyLength);
                            }
                            requestBodyChunks.push(chunk);
                        }
                        requesBodyLength += originalChunkLength;
                    });

                    req.on('end', () => {
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        //agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'end\')', context.id);
                        if (!requestEndSent) {
                            self.raiseRequestEndEvent(req, res, requestBodyChunks, requesBodyLength);
                            requestEndSent = true;
                        }
                    });

                    // Note: it's possible to write data using the `end` method as well,
                    // but that method calls `write` under the hood, and patching both
                    // leads to a doubly patched write method, which duplicates the body
                    let responseBodyChunks = [];
                    let responseBodyLength = 0;
                    const oldWrite = res.write;
                    res.write = function (chunk, encoding?, ...writeArgs): boolean {

                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        //agent.providers.contextManager.checkContextID('HttpProxy::(response.write())', context.id);

                        // Short circuit if we're not actually writing anything
                        if (typeof chunk === 'function' || typeof chunk === 'undefined') {
                            return oldWrite.call(this, chunk, encoding, ...writeArgs);
                        }

                        // If we don't have the necessary information to normalize
                        // to a string, the underlying API will throw, so we short
                        // circuit here and call the underlying API
                        if (typeof chunk !== 'string' && !Buffer.isBuffer(chunk)) {
                            return oldWrite.call(this, chunk, encoding, ...writeArgs);
                        }

                        // Save part or all of the chunk to the set of chunks,
                        // truncating if necessary to keep the set under the
                        // max body size
                        const originalChunkLength = chunk.length;
                        let normalizedChunk = chunk;
                        if (responseBodyLength < MAX_BODY_SIZE) {
                            if (responseBodyLength + originalChunkLength >= MAX_BODY_SIZE) {
                                normalizedChunk = normalizedChunk.slice(0, MAX_BODY_SIZE - responseBodyLength);
                            }
                            responseBodyChunks.push(normalizedChunk);
                        }
                        responseBodyLength += originalChunkLength;

                        return oldWrite.call(this, chunk, encoding, ...writeArgs);
                    };

                    res.on('finish', () => {
                        // TODO:  renable this check when we have an effective context tracking implementation in place
                        //agent.providers.contextManager.checkContextID('HttpProxy::(request - on(\'finish\')', context.id);

                        if (!requestEndSent) {
                            // If we got here, it means that the `res.end()` method
                            // was called before the body was received (if any). User's
                            // will often do this if returning an error status, or
                            // if they know there isn't a body associated with this
                            // request, so we report the body as not existing
                            self.raiseRequestEndEvent(req, res, [], 0);
                            requestEndSent = true;
                        }
                        self.raiseResponseEndEvent(req, res, responseBodyChunks, responseBodyLength);
                    });
                });
            };

            // Note: https.createServer and http.createServer have different signatures:
            // http.createServer([callback])
            // https.createServer(options[, callback])
            // We can't inspect the callback type because the callback is optional,
            // but we can inspect the `options` parameter since it is required for
            // HTTPS calls and HTTP calls don't accept an options object
            if (typeof options !== 'object') {
                cb = options;
                return oldCreateServer.call(this, internalCallback, ...args);
            } else {
                return oldCreateServer.call(this, options, internalCallback, ...args);
            }
        };
    }

    private setupInspectorExtensions(agent: IAgent): void {
        for (const inspector of this.inspectors) {
            inspector.init(agent);
        }
    }

    public addInspector(inspector: IServerRequestInspector) {
        if (this.proxiedModules.length) {
            throw new Error('Cannot add inspectors after the proxy has been initialized for the first time');
        }
        this.inspectors.push(inspector);
    }

    public init(agent: IAgent, httpModule) {
        this.agent = agent;
        // We can only initialize the proxies once, otherwise we will get n
        // copies of all messages because the proxies will nest inside each other
        if (this.proxiedModules.indexOf(httpModule) !== -1) {
            throw new Error('Cannot proxy a module that has already been proxied');
        }
        this.proxiedModules.push(httpModule);
        this.setupServerProxy(agent, httpModule);
        this.setupInspectorExtensions(agent);

        return httpModule;
    };
}

export class HttpProxy extends ProxyBase {

    private serverProxy = new ServerProxy();

    public get moduleName() { return 'http'; };

    public addServerInspector(inspector: IServerRequestInspector) {
        this.serverProxy.addInspector(inspector);
    }

    public init(agent: IAgent, httpModule, resolvedName) {
        this.serverProxy.init(agent, httpModule);
        return httpModule;
    };

    public get forceLoadModule(): boolean {
        return false;
    }
}
