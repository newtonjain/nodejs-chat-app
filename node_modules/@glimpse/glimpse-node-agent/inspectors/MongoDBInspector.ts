'use strict';

import { IAgent } from '../IAgent';
import { IContextManager } from '../messaging/IContextManager';
import { MongoDBProxy } from '../tracing/proxies/MongoDBProxy';
import { DateTimeValue } from '../configuration/DateTimeValue';
import Tracing from '../tracing/Tracing';
import { IProxyEvent } from '../tracing/IProxyEvent';
import _ = require('lodash');

/* tslint:disable:no-any */

interface IConnectionInfo {
    host: string;
    port: number;
    database: string;
    collectionName: string;
}

/**
 * Class that represents a set of data that we pass along as part of the "options"
 * parameter to various MongoDB calls. This lets us pass data between multiple proxy calls on the  
 * same call stack or call chain.
 */
export class GlimpseMongoDBOptions {

    private static CUSTOM_KEY = '__customOptions';

    private _operationName;
    private _messageSent: boolean = false;

    /**
     * Set the primary operation name for this call chain.  This is what is shown in the custom message.
     */
    public set operationName(name: string) {
        this._operationName = name;
    }

    /**
     * Get the operation name
     */
    public get operationName(): string {
        return this._operationName;
    }

    /**
     * Record that message is sent
     */
    public set messageSent(sent: boolean) {
        this._messageSent = sent;
    }

    /**
     * Get if message is sent
     */
    public get messageSent(): boolean {
        return this._messageSent;
    }

    /**
     * Return the GlimpseMongoDBOptions instance from the given object, or return undefined if not available. 
     */
    public static get(options: Object): GlimpseMongoDBOptions {
        let gopts: GlimpseMongoDBOptions;
        if (options) {
            gopts = options[GlimpseMongoDBOptions.CUSTOM_KEY];
        }
        return gopts;
    }

    /**
     * Remove the GlimpseMongoDBOptions instance from the given object
     */
    public static clear(options: Object) {
        if (options && options[GlimpseMongoDBOptions.CUSTOM_KEY]) {
            delete options[GlimpseMongoDBOptions.CUSTOM_KEY];
        }
    }

    /**
     *  Ensure the GlimpseMongoDBOptions instance exists on the given object, and return it.   
     */
    public static ensure(options: Object): GlimpseMongoDBOptions {
        let gopts: GlimpseMongoDBOptions = options[GlimpseMongoDBOptions.CUSTOM_KEY];
        if (!gopts) {
            gopts = new GlimpseMongoDBOptions();
            options[GlimpseMongoDBOptions.CUSTOM_KEY] = gopts;
        }
        return gopts;
    }
}

export class MongoDBInspector {
    private agent: IAgent;
    private contextManager: IContextManager;

    public init(agent: IAgent): any {
        this.agent = agent;
        this.contextManager = agent.providers.contextManager;

        Tracing.onAlways(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT, (event) => {
            this.insertInspector(event);
        });

        Tracing.onAlways(MongoDBProxy.EVENT_MONGODB_COLLECTION_INSERT_METHODS, (event) => {
            this.insertMethodsInspector(event);
        });

        Tracing.onAlways(MongoDBProxy.EVENT_MONGODB_COLLECTION_UPDATE_METHODS, (event) => {
            this.updateMethodsInspector(event);
        });

        Tracing.onAlways(MongoDBProxy.EVENT_MONGODB_COLLECTION_COUNT, (event) => {
            this.countInspector(event);
        });

        Tracing.onAlways(MongoDBProxy.EVENT_MONGODB_COLLECTION_DELETE_METHODS, (event) => {
            this.deleteMethodsInspector(event);
        });

        Tracing.onAlways(MongoDBProxy.EVENT_MONGODB_READ_METHODS, (event) => {
            this.readCompletedInspector(event);
        });

        Tracing.onAlways(MongoDBProxy.EVENT_MONGODB_START_READ, (event) => {
            this.readStartInspector(event);
        });
    };

    /** 
     *  sendAfterReadMessage
     */
    private sendAfterReadMessage(
        err: string,
        operation: string,
        startTime: DateTimeValue,
        query: Object,
        options: Object,
        ci: IConnectionInfo): any {
        const context = this.contextManager.currentContext();
        if (context) {
            const endTime = this.agent.providers.dateTime.now;
            this.agent.broker.sendMessage(
                {
                    operation: operation,
                    query: query,
                    startTime: startTime.format(),
                    duration: endTime.diff(startTime),
                    options: options,
                    connectionHost: ci.host,
                    connectionPort: ci.port,
                    database: ci.database,
                    collection: ci.collectionName
                },
                ['data-mongodb-read']);
        }
    };

    /**
     *  sendAfterInsertMessage
     */
    private sendAfterInsertMessage(
        err: string,
        operation: string,
        startTime: DateTimeValue,
        docs: Object[],
        numInserted: number,
        insertedIDs: number[],
        options: Object,
        ci: IConnectionInfo): any {
        const context = this.contextManager.currentContext();
        if (context) {
            const endTime = this.agent.providers.dateTime.now;
            this.agent.broker.sendMessage(
                {
                    operation: operation,
                    docs: docs,
                    count: numInserted,
                    insertedIds: insertedIDs,
                    startTime: startTime.format(),
                    duration: endTime.diff(startTime),
                    options: options,
                    connectionHost: ci.host,
                    connectionPort: ci.port,
                    database: ci.database,
                    collection: ci.collectionName
                },
                ['data-mongodb-insert']);
        }
    };

    /**
     * method to send an update completed message
     */
    private sendAfterUpdateMessage(
        err: string,
        operation: string,
        startTime: DateTimeValue,
        query: Object,
        updates: Object,
        matchedCount: number,
        modifiedCount: number,
        upsertedCount: number,
        options: Object,
        ci: IConnectionInfo): any {
        const context = this.contextManager.currentContext();
        if (context) {
            const endTime = this.agent.providers.dateTime.now;
            this.agent.broker.sendMessage(
                {
                    operation: operation,
                    query: query,
                    updates: updates,
                    matchedCount: matchedCount,
                    modifiedCount: modifiedCount,
                    upsertedCount: upsertedCount,
                    startTime: startTime.format(),
                    duration: endTime.diff(startTime),
                    options: options,
                    connectionHost: ci.host,
                    connectionPort: ci.port,
                    database: ci.database,
                    collection: ci.collectionName
                },
                ['data-mongodb-update']);
        }
    };

    /**
     * method to send a delete completed message.
     */
    private sendAfterDeleteMessage(
        err: string,
        operation: string,
        startTime: DateTimeValue,
        query: Object,
        numDeleted: number,
        options: Object,
        ci: IConnectionInfo): any {
        const context = this.contextManager.currentContext();
        if (context) {
            const endTime = this.agent.providers.dateTime.now;
            this.agent.broker.sendMessage(
                {
                    operation: operation,
                    query: query,
                    count: numDeleted,
                    startTime: startTime.format(),
                    duration: endTime.diff(startTime),
                    options: options,
                    connectionHost: ci.host,
                    connectionPort: ci.port,
                    database: ci.database,
                    collection: ci.collectionName
                },
                ['data-mongodb-delete']);
        }
    };

    /**
     * Handle insert method
     */
    private insertInspector(event: IProxyEvent) {
        // since insert implementation calls back in on insertMany, we need to override the operation name used
        GlimpseMongoDBOptions.ensure(event.data.originalArgs[1]).operationName = 'insert';
    };

    /**
     * Notify insert methods including 'insertMany' and 'insertOne'
     */
    private insertMethodsInspector(event: IProxyEvent) {
        const connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(event.data.originalThis);
        let docs = event.data.originalArgs[0];
        let options = event.data.originalArgs[1];
        const methodName = event.data.methodName;
        let count = 0;
        let insertedIDs = [];
        const result = event.data.result;

        if (typeof options === 'function') {
            options = undefined;
        }

        let operationName = methodName;
        const opts: GlimpseMongoDBOptions = GlimpseMongoDBOptions.get(options);
        if (opts) {
            if (opts.operationName) {
                operationName = opts.operationName;
            }

            // strip out the custom options as they're no longer necessary
            GlimpseMongoDBOptions.clear(options);
        }

        if (!options) {
            options = {};
        }
        else {
            // strip out the custom options as they're no longer necessary
            GlimpseMongoDBOptions.clear(options);
            options = _.cloneDeep(options);
            // strip out checkKeys as Mongo adds this
            options.checkKeys = undefined;
        }

        if (methodName === 'insertOne') {
            docs = [docs];
        }

        if (!event.data.err) {
            if (methodName === 'insertOne') {
                if (result) {
                    count = result.ops.length;
                    insertedIDs = [result.insertedId];
                }
            }
            else {
                if (result) {
                    count = result.insertedCount;
                    insertedIDs = result.insertedIds;
                }
            }
        }

        this.sendAfterInsertMessage(
            event.data.err,
            operationName,
            DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime),
            docs,
            count,
            insertedIDs,
            options,
            connectionInfo
        );
    };

    /**
     * Notify delete methods including 'deleteMany', 'deleteOne', 'findOneAndDelete', 'remove'
     */
    private deleteMethodsInspector(event: IProxyEvent) {
        const originalArgs = event.data.originalArgs;
        const filter = originalArgs[0];
        let options = originalArgs[1];
        const connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(event.data.originalThis);
        let count = 0;
        const result = event.data.result;
        const methodName = event.data.methodName;

        if (typeof options === 'function') {
            options = undefined;
        }

        if (!options) {
            options = {};
        }
        else {
            GlimpseMongoDBOptions.clear(options);
            options = _.cloneDeep(options);
        }

        if (result) {
            if (methodName === 'findOneAndDelete') {
                if (result.value) {
                    count = 1;
                }
            }
            else if (methodName === 'remove') {
                if (result.result) {
                    count = result.result.n;
                }
            }
            else {
                count = result.deletedCount;
            }
        }

        this.sendAfterDeleteMessage(
            event.data.err,
            methodName,
            DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime),
            filter,
            count,
            options,
            connectionInfo
        );
    };

    /**
     * Notify update operation
     */
    private updateMethodsInspector(event: IProxyEvent) {
        const connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(event.data.originalThis);
        const originalArgs = event.data.originalArgs;
        const result = event.data.result;
        const methodName = event.data.methodName;
        let filter = originalArgs[0];
        let update = originalArgs[1];
        let options = originalArgs[2];
        let matchedCount = 0;
        let modifiedCount = 0;
        let upsertedCount = 0;

        if (typeof options === 'function') {
            options = undefined;
        }

        if (!options) {
            options = {};
        }
        else {
            // strip out the custom options as they're no longer necessary
            GlimpseMongoDBOptions.clear(options);
            options = _.cloneDeep(options);
        }

        if (result) {
            matchedCount = result.matchedCount;
            modifiedCount = result.modifiedCount;
            upsertedCount = result.upsertedCount;

            if (methodName === 'findOneAndUpdate') {
                if (result.lastErrorObject.updatedExisting) {
                    upsertedCount = 0;
                    matchedCount = 1;
                    modifiedCount = 1;
                }
                else if (result.lastErrorObject.n > 0) {
                    upsertedCount = 1;
                    matchedCount = 1;
                    modifiedCount = 0;
                }
                else {
                    upsertedCount = 0;
                    matchedCount = 0;
                    modifiedCount = 0;
                }
            }
        }

        this.sendAfterUpdateMessage(
            event.data.err,
            event.data.methodName,
            DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime),
            filter,
            update,
            matchedCount,
            modifiedCount,
            upsertedCount,
            options,
            connectionInfo
        );
    };

    /**
     *  Inspect collection read count 
     */
    private countInspector(event: IProxyEvent) {
        const originalThis = event.data.originalThis;
        const originalArgs = event.data.originalArgs;
        const connectionInfo = MongoDBInspector.GetConnectionInfoFromCollection(originalThis);
        let query = originalArgs[0];
        let options = event.data.originalArgs[1];

        if (typeof options === 'function') {
            options = undefined;
        }

        if (!options) {
            options = {};
        }

        this.sendAfterReadMessage(
            event.data.err,
            event.data.methodName,
            DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime),
            query,
            options,
            connectionInfo
        );
    };

    /*
     * Record the operation name for read operations
     */
    private readStartInspector(event: IProxyEvent) {
        const originalThis = event.data.originalThis;

        let cursorCustomOpts = GlimpseMongoDBOptions.ensure(originalThis.s.cmd);
        if (!cursorCustomOpts.operationName) {
            cursorCustomOpts.operationName = event.data.methodName;
        }
    }

    /**
     * Notify read operations 
     */
    private readCompletedInspector(event: IProxyEvent) {
        const originalThis = event.data.originalThis;
        const connectionInfo: IConnectionInfo = MongoDBInspector.GetConnectionInfoFromCursor(originalThis);
        let operationName = event.data.methodName;

        let cursorCustomOpts = GlimpseMongoDBOptions.ensure(originalThis.s.cmd);
        if (cursorCustomOpts.operationName) {
            operationName = cursorCustomOpts.operationName;
        }

        if (!cursorCustomOpts.messageSent) {
            cursorCustomOpts.messageSent = true;

            // clone options & clear out Glimpse opts so we don't include them in Glimpse messages
            const opts = _.cloneDeep(originalThis.s.cmd);
            GlimpseMongoDBOptions.clear(opts);

            this.sendAfterReadMessage(
                event.data.err,
                operationName,
                DateTimeValue.fromMomentAndHRTime(event.data.startTime, event.data.hrtime),
                originalThis.s.cmd.query,
                opts,
                connectionInfo
            );
        }
    }

    /**
     * method to extract connection info details from a MongoDB Cusror istance
     */
    private static GetConnectionInfoFromCursor(cursor): IConnectionInfo {
        const dbname = cursor.options.db.s.databaseName;
        return {
            host: cursor.topology.s.serverDetails.host,
            port: cursor.topology.s.serverDetails.port,
            database: dbname,
            collectionName: cursor.ns.substring(dbname.length + 1)
        };
    }

    /**
     * method to extract connection info details from a MongoDB Collection istance
     */
    private static GetConnectionInfoFromCollection(collection): IConnectionInfo {
        return {
            host: collection.s.topology.s.host,
            port: collection.s.topology.s.port,
            database: collection.s.dbName,
            collectionName: collection.s.name
        };
    }
}
