'use strict';

/* tslint:disable:no-any */

import {IProxy} from './IProxy';
import {IProxy as ITracingProxy} from '../tracing/IProxy';
import {IAgent} from '../IAgent';

interface ProxyInfo {
    proxyInstance: IProxy;
    proxiedModule: any;
}

interface TracingProxyInfo {
    proxyInstance: ITracingProxy;
    isInitialized: boolean;
}

export class ModuleManager {
    private agent: IAgent;
    private proxiedModule: any;
    private originalRequire: any;

    // For the time being, proxies using the new tracing module are kept side-by-side
    // with the old style of proxies. Eventually, everything will be migrated to the
    // new format and this module can be simplified.
    private proxies: { [moduleName: string]: ProxyInfo } = {};
    private tracingProxies: { [moduleName: string]: TracingProxyInfo[] } = {};

    public init(agent: IAgent, module: any) {
        this.agent = agent;
        this.proxiedModule = module;
        this.originalRequire = module.prototype.require;
        this.setupProxy();

        for (const moduleName in this.proxies) {
            if (this.proxies.hasOwnProperty(moduleName) && this.proxies[moduleName].proxyInstance.forceLoadModule) {
                require(moduleName);
            }
        }

        for (const moduleName in this.tracingProxies) {
            if (!this.tracingProxies.hasOwnProperty(moduleName)) {
                continue;
            }
            for (const proxy of this.tracingProxies[moduleName]) {
                if (proxy.proxyInstance.forceLoadModule) {
                    require(moduleName);
                }
            }
        }
    };

    public addProxy(proxyInstance: IProxy, moduleName?: string) {
        moduleName = moduleName || proxyInstance.moduleName;

        this.proxies[moduleName] = {
            proxyInstance: proxyInstance,
            proxiedModule: undefined
        };

        if (this.isInitialized() && proxyInstance.forceLoadModule) {
            require(moduleName);
        }
    };

    public addTracingProxy(proxyInstance: ITracingProxy, moduleNames?: string[]) {
        if (!moduleNames) {
            moduleNames = proxyInstance.getModuleNames();
        }

        for (const moduleName of moduleNames) {
            if (!this.tracingProxies[moduleName]) {
                this.tracingProxies[moduleName] = [];
            }
            this.tracingProxies[moduleName].push({
                proxyInstance,
                isInitialized: false
            });
            if (proxyInstance.forceLoadModule) {
                require(moduleName);
            }
        }
    }

    private isInitialized() {
        return (this.agent !== undefined);
    }

    private setupProxy() {

        const self = this;

        const glimpseRequire = function glimpseRequire(id) {

            // _resolveFilename isn't cleanly exposed, but we can access via `this.constructor`.
            // require.resolve(id) doesn't work correctly here since it will run in the context of the Glimpse.Agent
            // module, and not in the context of the module we're trying to load.
            let resolvedPath = this.constructor._resolveFilename(id, this);

            const originalModule = self.originalRequire.call(this, id);
            let overriddenModule;

            if (self.proxies[id] && self.proxies[id].proxyInstance.isEnabledForModule(id, self.agent.providers.configSettings)) {
                if (!self.proxies[id].proxiedModule) {
                    self.proxies[id].proxiedModule = self.proxies[id].proxyInstance.init(self.agent, originalModule, resolvedPath);
                }
                overriddenModule = self.proxies[id].proxiedModule;
            }

            // There are some intersting things going on here with regards to
            // supporting multiple proxies. There are a two competing scenarios
            // that need to be accounted for:
            // 1) The module being proxied assigns a function to module.exports
            //    This function needs to be proxied. This requires that this
            //    function be intercepted and proxied, and the function returned
            //    from requiring that module must be intercepted and overwritten.
            //    This effectively limits this module to a single proxy
            // 2) The module being proxied assigns a number of functions as
            //    properties module.exports. These may be tightly coupled (e.g.
            //    express), or loosely related by category (e.g. http). In both
            //    cases it is not necessary to intercept the object returned
            //    from requiring module, allowing multiple proxies to be loaded
            // To enforce the restriction of a single proxy for 1), but still
            // allow 2), we check the return value from the proxy init method.
            // If it returns something, then this means that proxy is intercepting
            // and overwriting the returned value from requiring the module,
            // indicating we are dealing with case 1). If init does not return
            // a value, this indicates we are dealing with case 2) and allow
            // multiple proxies to init themselves. It is the responsibility
            // of the proxies to ensure they don't step on each other's toes in
            // this case.
            if (self.tracingProxies[id]) {
                for (const proxy of self.tracingProxies[id]) {
                    if (!proxy.isInitialized && proxy.proxyInstance.isEnabledForModule(id, self.agent.providers.configSettings)) {
                        const newModule = proxy.proxyInstance.init(overriddenModule || originalModule, resolvedPath);
                        if (newModule && overriddenModule) {
                            throw new Error(`Only one proxy can override the module.exports object for ${id} at a time`);
                        }
                        overriddenModule = overriddenModule || newModule;
                        proxy.isInitialized = true;
                    }
                }
            }

            return overriddenModule || originalModule;
        };

        this.proxiedModule.prototype.require = glimpseRequire;
    };
};
