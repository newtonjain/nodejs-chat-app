'use strict';

import { DateTimeValue } from '../configuration/DateTimeValue';
import { IAgent } from '../IAgent';
import { IDateTime } from '../configuration/IDateTime';
import { IServerRequestInspector } from './IServerRequestInspector';
import { RequestHelper } from './util/HttpHelper';
import { ResponseListener } from './util/ResponseListener';
import { HttpHelper } from './util/HttpHelper';

import * as http from 'http';

import _ = require('lodash');

class InspectorResponseContext {
    public constructor(public startTime: DateTimeValue) {
        this.headers = {};
    }

    public headers: { [key: string]: string[] };
}

interface IServerResponse extends http.ServerResponse {
    __glimpseRequestInspectorContext: InspectorResponseContext;
}

export class WebInspector implements IServerRequestInspector {
    private agent: IAgent;
    private dateTime: IDateTime;

    public requestStart(req: http.IncomingMessage, res: http.ServerResponse) {

        const context = HttpHelper.getContext(req);
        if (context) {

            const inspectedResponse = <IServerResponse>res;

            inspectedResponse.__glimpseRequestInspectorContext = new InspectorResponseContext(this.dateTime.now);

            function onHeaders(newHeaders) {
                _.assign(inspectedResponse.__glimpseRequestInspectorContext.headers, newHeaders);
            };

            const responseListener = ResponseListener.attachListener(res);

            responseListener.on(ResponseListener.headersEvent, onHeaders);
        }
    }

    /* tslint:disable:no-any */
    public requestEnd(req: http.IncomingMessage, res: http.ServerResponse, content: Array<any>, size: number) {
        /* tslint:enable:no-any */

        // pull context from request instead of context manager, as request/response is more reliable 
        const context = HttpHelper.getContext(req);
        if (context) {

            const inspectedResponse = <IServerResponse>res;

            // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307
            // Add support for base64 encoding non-text content by setting the encoding here
            const encoding = 'utf8';
            for (let i = 0; i < content.length; i++) {
                if (Buffer.isBuffer(content[i])) {
                    content[i] = content[i].toString();
                }
            }

            const data = {
                protocol: {
                    identifier: RequestHelper.protocol(req),
                    version: req.httpVersion
                },
                url: RequestHelper.protocol(req) + '://' + RequestHelper.host(req) + req.url,
                method: req.method,
                headers: req.headers,
                startTime: inspectedResponse.__glimpseRequestInspectorContext.startTime.format(),
                isAjax: RequestHelper.header(req, '__glimpse-isAjax') === 'true',
                clientIp: req.socket.remoteAddress,
                body: {
                    size,
                    encoding,
                    content: content.join('')
                }
            };

            const indices = {
                'request-url': data.url,
                'request-method': data.method,
                'request-datetime': data.startTime
            };

            const types = ['web-request'];

            this.agent.broker.sendMessage(data, types, indices, context);
        }
    }

    /* tslint:disable:no-any */
    public responseEnd(req: http.IncomingMessage, res: http.ServerResponse, content: Array<any>, size: number) {
        /* tslint:enable:no-any */

        // pull context from request instead of context manager, as request/response is more reliable 
        const context = HttpHelper.getContext(req);
        if (context) {
            const inspectedResponse = <IServerResponse>res;

            const endTime = this.dateTime.now;

            // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307
            // Add support for base64 encoding non-text content by setting the encoding here
            const encoding = 'utf8';
            for (let i = 0; i < content.length; i++) {
                if (Buffer.isBuffer(content[i])) {
                    content[i] = content[i].toString();
                }
            }

            const data = {
                url: RequestHelper.protocol(req) + '://' + RequestHelper.host(req) + req.url,
                headers: inspectedResponse.__glimpseRequestInspectorContext.headers,
                statusCode: res.statusCode,
                duration: endTime.diff(inspectedResponse.__glimpseRequestInspectorContext.startTime),
                endTime: endTime.format(),
                body: {
                    size,
                    encoding,
                    content: content.join('')
                }
            };

            const indices = {
                'request-duration': data.duration,
                'request-status-code': data.statusCode
            };

            const contentType = data.headers['content-type'];

            if (contentType && contentType.length > 0) {
                indices['request-content-type'] = contentType[0];
            }

            const types = ['web-response'];

            this.agent.broker.sendMessage(data, types, indices, context);
        }
    }

    public init(agent: IAgent) {
        this.agent = agent;
        this.dateTime = agent.providers.dateTime;
    }
}
